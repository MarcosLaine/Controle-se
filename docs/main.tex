\documentclass[12pt,a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[brazil]{babel}
\usepackage{geometry}
\geometry{margin=2.5cm}

\usepackage[final]{graphicx}
\usepackage{float}
\usepackage{caption}
\captionsetup{font=small,labelfont=bf}
\usepackage{amsmath}
\usepackage{hyperref}
\hypersetup{colorlinks=true, linkcolor=black, urlcolor=blue}

\title{Controle-se: Aplicação Web de Controle de Gastos Pessoais\\
\large AED III — Trabalho Prático}
\author{Ana Carolina Couto Machado e Marcos Paulo Da Silva Laine.}
\date{\today}

\begin{document}
\maketitle

\section*{Formulário de Identificação}
\begin{table}[H]
\centering
\begin{tabular}{|l|p{10cm}|}
\hline
\textbf{Disciplina} & Algoritmos e Estruturas de Dados III \\
\hline
\textbf{Professor} & Walisson Ferreira \\
\hline
\textbf{Período} & 2025/1 \\
\hline
\textbf{Alunos} & Ana Carolina Couto Machado e Marcos Paulo Da Silva Laine \\
\hline
\textbf{Título do Projeto} & Controle-se: Aplicação Web de Controle de Gastos Pessoais \\
\hline
\textbf{Data de Entrega} & \today \\
\hline
\textbf{Repositório} & \url{https://github.com/marcoslaine/controle-se} \\
\hline
\end{tabular}
\end{table}

\newpage
\part*{Fase I}
\addcontentsline{toc}{part}{Fase I}

\section{Descrição do Problema e Tema}
O \textbf{Controle-se} é uma aplicação web para controle de gastos pessoais. O sistema permite
registrar \textbf{gastos} e \textbf{receitas}, categorizá-los, gerenciar contas (carteira, banco, cartão),
definir orçamentos mensais por categoria e visualizar indicadores (saldo por conta, execução do orçamento e histórico).

\subsection*{Requisitos}
\begin{itemize}
  \item \textbf{Funcionais}: Definição de orçamento; categorização de gasto; inserção, remoção e edição de gasto; \
  inserção de contas bancárias; visualização geral; visualização de gastos recentes; filtrar gastos por categorias
  \item \textbf{Não funcionais}: dados criptografados; armazenamento local; dados comprimidos;
\end{itemize}

\section{Diagrama de Caso de Uso}
\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth,height=.86\textheight,keepaspectratio]{caso.png}
  \caption{Diagrama de Caso de Uso do \textit{Controle-se}.}
\end{figure}

\section{DER Conceitual}
\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth,height=.86\textheight,keepaspectratio]{DER.png}
  \caption{DER conceitual com relacionamento \textbf{N:N} entre Categoria e Gasto.}
\end{figure}

\section{Aderência aos Requisitos}
\begin{itemize}
  \item \textbf{Mínimo de 3 tabelas além de usuário}: \textit{Conta, Categoria, Gasto, Orçamento e receita}.
  \item \textbf{1:N}: Usuário–Conta; Conta–Gasto.
  \item \textbf{N:N}: \textbf{Categoria–Gasto} via \textit{GASTO\_CATEGORIA}.
  \item \textbf{Tipos}: data (\texttt{Gasto.data}); real (\texttt{Gasto.valor});
        string (vários); \textbf{string multivalorado} representado pela associação N:N (um gasto pode ter lista de categorias) e \textbf{atributo multivalorado nativo} \texttt{Gasto.observacoes} como array de strings.
\end{itemize}

\newpage
\part*{Fase II}
\addcontentsline{toc}{part}{Fase II}

\section{Estruturas de Dados Implementadas}

\subsection{Árvore B+ (Índices Primários)}

A \textbf{Árvore B+} foi implementada como estrutura de indexação primária para todas as tabelas do sistema.
É uma árvore de busca balanceada que mantém os dados ordenados e permite buscas, inserções e remoções eficientes.

\subsubsection*{Características da Implementação}
\begin{itemize}
  \item \textbf{Ordem}: 4 (número máximo de filhos por nó)
  \item \textbf{Número máximo de chaves}: 3 (ordem - 1)
  \item \textbf{Número mínimo de filhos} (nós internos não-raiz): 2 ($\lceil$4/2$\rceil$)
  \item \textbf{Número mínimo de chaves} (nós internos não-raiz): 1 ($\lceil$4/2$\rceil$ - 1)
  \item \textbf{Nós folha}: Armazenam todos os registros de dados e são encadeados para navegação sequencial
  \item \textbf{Nós internos}: Armazenam apenas chaves de roteamento e ponteiros para filhos
  \item \textbf{Balanceamento}: Automático através de divisão e fusão de nós
\end{itemize}

\subsubsection*{Aplicações no Sistema}
\begin{itemize}
  \item \texttt{tabelaUsuarios}: ID\_Usuario $\rightarrow$ Usuario
  \item \texttt{tabelaCategorias}: ID\_Categoria $\rightarrow$ Categoria
  \item \texttt{tabelaGastos}: ID\_Gasto $\rightarrow$ Gasto
  \item \texttt{tabelaReceitas}: ID\_Receita $\rightarrow$ Receita
  \item \texttt{tabelaContas}: ID\_Conta $\rightarrow$ Conta
  \item \texttt{tabelaOrcamentos}: ID\_Orcamento $\rightarrow$ Orcamento
  \item \texttt{tabelaTags}: ID\_Tag $\rightarrow$ Tag
\end{itemize}

\subsubsection*{Operações Implementadas}
\begin{itemize}
  \item \textbf{inserir(chave, dados)}: Inserção com balanceamento automático — O(log n)
  \item \textbf{buscar(chave)}: Busca por chave primária — O(log n)
  \item \textbf{remover(chave)}: Remoção lógica (lápide) — O(log n)
  \item \textbf{buscarIntervalo(inicio, fim)}: Busca por intervalo de chaves — O(log n + m)
  \item \textbf{listarTodos()}: Percurso sequencial nas folhas — O(n)
\end{itemize}

\subsection{Hash Extensível (Índices Secundários e Relacionamentos)}

O \textbf{Hash Extensível} foi implementado para gerenciar relacionamentos 1:N, N:N e índices secundários.
É uma estrutura de hash dinâmica que cresce conforme necessário, mantendo complexidade de busca O(1) médio.

\subsubsection*{Características da Implementação}
\begin{itemize}
  \item \textbf{Capacidade por bucket}: 3 registros
  \item \textbf{Profundidade global}: Número de bits usados para indexar o diretório
  \item \textbf{Profundidade local}: Número de bits usados por cada bucket
  \item \textbf{Crescimento dinâmico}: Diretório duplica quando bucket transborda e profundidades coincidem
\end{itemize}

\subsubsection*{Aplicações no Sistema}

\textbf{Relacionamentos 1:N (Foreign Keys):}
\begin{itemize}
  \item \texttt{indiceUsuarioCategorias}: Usuario $\rightarrow$ Lista<Categoria>
  \item \texttt{indiceUsuarioGastos}: Usuario $\rightarrow$ Lista<Gasto>
  \item \texttt{indiceUsuarioReceitas}: Usuario $\rightarrow$ Lista<Receita>
  \item \texttt{indiceUsuarioContas}: Usuario $\rightarrow$ Lista<Conta>
  \item \texttt{indiceUsuarioOrcamentos}: Usuario $\rightarrow$ Lista<Orcamento>
  \item \texttt{indiceUsuarioTags}: Usuario $\rightarrow$ Lista<Tag>
  \item \texttt{indiceCategoriaOrcamentos}: Categoria $\rightarrow$ Lista<Orcamento>
\end{itemize}

\textbf{Relacionamento N:N:}
\begin{itemize}
  \item \texttt{indiceCategoriaGastos}: Categoria $\rightarrow$ Lista<Gasto>
  \item \texttt{indiceGastoCategorias}: Gasto $\rightarrow$ Lista<Categoria>
  \item \texttt{indiceTagGastos}: Tag $\rightarrow$ Lista<Gasto>
  \item \texttt{indiceGastoTags}: Gasto $\rightarrow$ Lista<Tag>
  \item \texttt{indiceTagReceitas}: Tag $\rightarrow$ Lista<Receita>
  \item \texttt{indiceReceitaTags}: Receita $\rightarrow$ Lista<Tag>
\end{itemize}

\textbf{Índices para Consultas Específicas:}
\begin{itemize}
  \item \texttt{indiceEmailUsuarios}: Hash(Email) $\rightarrow$ Usuario (para login)
  \item \texttt{indiceDataGastos}: Hash(Data) $\rightarrow$ Lista<Gasto> (filtro por data)
  \item \texttt{indiceDataReceitas}: Hash(Data) $\rightarrow$ Lista<Receita> (filtro por data)
  \item \texttt{indiceTipoContas}: Hash(Tipo) $\rightarrow$ Lista<Conta> (filtro por tipo)
\end{itemize}

\subsubsection*{Operações Implementadas}
\begin{itemize}
  \item \textbf{inserir(chave, valor)}: Inserção com divisão de bucket se necessário — O(1) médio
  \item \textbf{buscar(chave)}: Retorna lista de valores associados — O(1) médio
  \item \textbf{remover(chave)}: Remove todas entradas com a chave — O(1) médio
  \item \textbf{expandirDiretorio()}: Duplica diretório quando necessário — $O(2^d)$ onde $d$ = profundidade
\end{itemize}

\section{Análise de Complexidade}

\begin{table}[H]
\centering
\small
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Operação} & \textbf{Estrutura} & \textbf{Complexidade} & \textbf{Caso} \\
\hline
Busca por ID (chave primária) & Árvore B+ & O(log n) & Pior caso \\
Inserção com nova chave & Árvore B+ & O(log n) & Pior caso \\
Remoção lógica (lápide) & Árvore B+ & O(log n) & Pior caso \\
Busca por intervalo & Árvore B+ & O(log n + m) & m = registros retornados \\
Listagem completa & Árvore B+ & O(n) & Percurso sequencial \\
\hline
Busca por FK ou atributo & Hash Extensível & O(1) & Caso médio \\
Inserção em índice secundário & Hash Extensível & O(1) & Caso médio \\
Remoção de índice secundário & Hash Extensível & O(1) & Caso médio \\
Filtro por categoria & Hash Extensível & O(1 + k) & k = registros da categoria \\
Filtro por data & Hash Extensível & O(1 + k) & k = registros da data \\
Login (busca por email) & Hash Extensível & O(1) & Caso médio \\
\hline
\end{tabular}
\caption{Complexidade temporal das operações implementadas.}
\end{table}

\section{Persistência em Disco}

O sistema implementa persistência de dados utilizando \textbf{serialização Java} para salvar e carregar
as estruturas de dados em arquivos binários \texttt{.db}.

\subsection*{Arquivos de Persistência}
\begin{itemize}
  \item \texttt{usuarios.db}: Tabela de usuários
  \item \texttt{categorias.db}: Tabela de categorias
  \item \texttt{gastos.db}: Tabela de gastos
  \item \texttt{receitas.db}: Tabela de receitas
  \item \texttt{contas.db}: Tabela de contas bancárias
  \item \texttt{orcamentos.db}: Tabela de orçamentos
  \item \texttt{tags.db}: Tabela de tags
  \item \texttt{contadores.db}: Contadores de IDs auto-incrementais
  \item \texttt{categoria\_gasto.db}: Relacionamento N:N entre Categoria e Gasto
  \item \texttt{transacao\_tag.db}: Relacionamento N:N entre Transações (Gastos/Receitas) e Tags
\end{itemize}

\subsection*{Estratégia de Persistência}
\begin{itemize}
  \item \textbf{Salvamento}: Após cada operação de escrita (inserção, atualização, remoção)
  \item \textbf{Carregamento}: Automático na inicialização do servidor
  \item \textbf{Formato}: Serialização Java (ObjectOutputStream/ObjectInputStream)
  \item \textbf{Exclusão lógica}: Registros marcados como \texttt{ativo = false} (lápide)
  \item \textbf{Verificação de Índices}: O sistema realiza verificação completa de integridade dos índices na inicialização, checando todos os índices primários (B+ Tree) e secundários essenciais (Hash Extensível). Se algum índice primário estiver ausente, o sistema automaticamente reconstrói todos os índices a partir dos dados persistidos, garantindo consistência e recuperação automática de possíveis corrupções.
\end{itemize}

\section{Operações CRUD Implementadas}

\subsection{Usuários}
\begin{itemize}
  \item \textbf{Create}: \texttt{cadastrarUsuario(nome, email, senha)} — verifica unicidade de email
  \item \textbf{Read}: \texttt{buscarUsuario(id)}, \texttt{buscarUsuarioPorEmail(email)}
  \item \textbf{Update}: \texttt{atualizarUsuario(id, novaSenha)}
  \item \textbf{Delete}: Exclusão lógica com \texttt{ativo = false}
  \item \textbf{Auth}: \texttt{autenticarUsuario(email, senha)}
\end{itemize}

\subsection{Categorias}
\begin{itemize}
  \item \textbf{Create}: \texttt{cadastrarCategoria(nome, idUsuario)}
  \item \textbf{Read}: \texttt{buscarCategoria(id)}, \texttt{listarCategoriasPorUsuario(idUsuario)}
  \item \textbf{Update}: \texttt{atualizarCategoria(id, novoNome)}
  \item \textbf{Delete}: \texttt{removerCategoria(id)} — exclusão lógica
\end{itemize}

\subsection{Gastos e Receitas}
\begin{itemize}
  \item \textbf{Create}: \texttt{registrarGasto(...)}, \texttt{registrarReceita(...)}
  \item \textbf{Read}: Busca por ID, por usuário, por categoria, por data
  \item \textbf{Update}: \texttt{atualizarGasto(...)}, \texttt{atualizarReceita(...)}
  \item \textbf{Delete}: Exclusão lógica
  \item \textbf{Filtros}: Combinação de categoria + data usando índices Hash
\end{itemize}

\subsection{Contas Bancárias}
\begin{itemize}
  \item \textbf{Create}: \texttt{cadastrarConta(nome, tipo, saldoInicial, idUsuario)}
  \item \textbf{Read}: \texttt{buscarConta(id)}, \texttt{listarContasPorUsuario(idUsuario)}
  \item \textbf{Update}: \texttt{atualizarConta(id, novoNome, novoSaldo)}
  \item \textbf{Delete}: Exclusão lógica
\end{itemize}

\subsection{Orçamentos}
\begin{itemize}
  \item \textbf{Create}: \texttt{cadastrarOrcamento(valorPlanejado, periodo, idCategoria, idUsuario)}
  \item \textbf{Read}: \texttt{buscarOrcamento(id)}, \texttt{listarOrcamentosPorUsuario(idUsuario)}
  \item \textbf{Update}: \texttt{atualizarOrcamento(id, novoValor)}
  \item \textbf{Delete}: Exclusão lógica
\end{itemize}

\subsection{Tags (Sistema de Etiquetas)}
\begin{itemize}
  \item \textbf{Create}: \texttt{cadastrarTag(nome, cor, idUsuario)} — cria tag personalizada com cor em hexadecimal
  \item \textbf{Read}: \texttt{buscarTag(id)}, \texttt{listarTagsPorUsuario(idUsuario)}
  \item \textbf{Update}: \texttt{atualizarTag(id, novoNome, novaCor)}
  \item \textbf{Delete}: Exclusão lógica
  \item \textbf{Associação}: \texttt{associarTagTransacao(idTransacao, tipoTransacao, idTag)}
  \item \textbf{Consultas}: \texttt{buscarTagsGasto(idGasto)}, \texttt{buscarTagsReceita(idReceita)}
  \item \textbf{Filtros}: \texttt{buscarGastosPorTag(idTag)}, \texttt{buscarReceitasPorTag(idTag)}
\end{itemize}

\noindent \textbf{Características das Tags:}
\begin{itemize}
  \item Sistema de etiquetas personalizáveis para organização de transações
  \item Cada tag possui nome único, cor em formato hexadecimal (ex: \texttt{\#3498db})
  \item Relacionamento N:N com Gastos e Receitas (uma transação pode ter múltiplas tags)
  \item Filtro de transações por tags no frontend para análise rápida
  \item Interface visual com badges coloridos para identificação imediata
\end{itemize}

\section{Arquitetura do Sistema}

O sistema implementa uma arquitetura de três camadas:

\subsection*{Camada 1: Frontend Web}
\begin{itemize}
  \item \textbf{Tecnologia}: HTML5 + CSS3 + JavaScript (ES6+)
  \item \textbf{Responsabilidades}: Interface do usuário, validação de formulários, comunicação com API REST
  \item \textbf{Arquivos}: \texttt{index.html}, \texttt{styles.css}, \texttt{app.js}
\end{itemize}

\subsection*{Camada 2: API REST (Servidor Java)}
\begin{itemize}
  \item \textbf{Tecnologia}: Java 11+ com \texttt{com.sun.net.httpserver.HttpServer}
  \item \textbf{Responsabilidades}: Roteamento de requisições, validação de dados, lógica de negócios
  \item \textbf{Endpoints}: Autenticação, Categorias, Contas, Gastos, Receitas, Orçamentos, Tags, Dashboard
  \item \textbf{Formato}: JSON para entrada e saída
  \item \textbf{Arquivo principal}: \texttt{ControleSeServer.java}
\end{itemize}

\noindent \textbf{Principais Endpoints Implementados:}
\begin{itemize}
  \item \texttt{POST /api/auth/login} — Autenticação de usuário
  \item \texttt{POST /api/categories} — Criar categoria
  \item \texttt{GET /api/categories?userId=X} — Listar categorias do usuário
  \item \texttt{POST /api/expenses} — Registrar gasto (com tags opcionais)
  \item \texttt{POST /api/incomes} — Registrar receita (com tags opcionais)
  \item \texttt{GET /api/transactions?userId=X} — Listar transações (inclui tags)
  \item \texttt{POST /api/tags} — Criar tag personalizada
  \item \texttt{GET /api/tags?userId=X} — Listar tags do usuário
  \item \texttt{PUT /api/tags/\{id\}} — Atualizar tag
  \item \texttt{DELETE /api/tags/\{id\}} — Excluir tag (lógica)
\end{itemize}

\subsection*{Camada 3: Banco de Dados (Estruturas de Dados)}
\begin{itemize}
  \item \textbf{Tecnologia}: Árvore B+ e Hash Extensível implementados manualmente
  \item \textbf{Responsabilidades}: Armazenamento, indexação, busca eficiente, persistência
  \item \textbf{Arquivos}: \texttt{BancoDados.java}, \texttt{ArvoreBPlus.java}, \texttt{HashExtensivel.java}
\end{itemize}

\section{Atributos Multivalorados}

\subsection{Implementação}

\textbf{Atributo Multivalorado Nativo:}
\begin{itemize}
  \item \textbf{Campo}: \texttt{Gasto.observacoes} como \texttt{String[]}
  \item \textbf{Tipo}: Array de strings para múltiplas observações por gasto
  \item \textbf{Persistência}: Via Java Serialization junto com o objeto \texttt{Gasto}
  \item \textbf{Operações}: Adição dinâmica de observações via método \texttt{adicionarObservacao()}
\end{itemize}

\textbf{Relacionamentos N:N (Simulando Multivalorados):}
\begin{itemize}
  \item \textbf{Categoria-Gasto}: Via tabela \texttt{CategoriaGasto}
  \item \textbf{Tag-Transação}: Via tabela \texttt{TransacaoTag}
  \item \textbf{Índices}: Hash Extensível para busca eficiente
  \item \textbf{Integridade}: Chaves estrangeiras para consistência
\end{itemize}

\subsection{Características Técnicas}

\begin{itemize}
  \item \textbf{Serialização}: Arrays nativos preservados na persistência
  \item \textbf{Performance}: Acesso direto sem joins para observações
  \item \textbf{Flexibilidade}: Tamanho dinâmico do array de observações
  \item \textbf{UI}: Campo textarea com separação por vírgula/quebra de linha
\end{itemize}

\section{Testes e Validação}

\subsection*{Cenários Testados}
\begin{itemize}
  \item Cadastro de usuário com email único (validação de duplicação)
  \item Login com credenciais válidas e inválidas
  \item Operações CRUD completas em todas as entidades
  \item Filtros combinados: categoria + data + tags para gastos e receitas
  \item Persistência: reinicialização do servidor mantém dados
  \item Exclusão lógica: registros removidos não aparecem mas permanecem no arquivo
  \item Crescimento dinâmico do Hash Extensível com múltiplas inserções
  \item Balanceamento da Árvore B+ com inserções e remoções
  \item Associação N:N de tags com múltiplas transações
  \item Criação de categoria inline durante cadastro de gasto
  \item Filtro de transações por tags com busca client-side
  \item Atributo multivalorado: múltiplas observações por gasto
  \item Persistência de arrays de strings via serialização
\end{itemize}

\subsection*{Validações Implementadas}
\begin{itemize}
  \item Email único para usuários
  \item IDs auto-incrementais para todas as entidades
  \item Verificação de existência antes de operações de atualização/remoção
  \item Tratamento de exceções em operações de I/O
  \item Validação de relacionamentos (FK válidas)
\end{itemize}

\section{Sistema de Relatórios}

\subsection{Implementação}

O sistema de relatórios foi implementado como uma funcionalidade completa que permite análise detalhada dos dados financeiros do usuário através de dashboards interativos e exportação de dados.

\subsubsection*{Backend (Java)}
\begin{itemize}
  \item \textbf{ReportsHandler}: Novo handler para processar requisições de relatórios
  \item \textbf{Métodos de busca por período}: \texttt{buscarGastosPorPeriodo()} e \texttt{buscarReceitasPorPeriodo()}
  \item \textbf{Exportação de dados}: Métodos para exportar relatórios em CSV e XLSX
  \item \textbf{Análise de dados}: Cálculos de totais, análise por categoria, conta e evolução mensal
\end{itemize}

\subsubsection*{Frontend (JavaScript + Chart.js)}
\begin{itemize}
  \item \textbf{Dashboards interativos}: 4 tipos de visualizações gráficas
  \item \textbf{Controles de período}: Mensal, anual e período personalizado
  \item \textbf{Exportação}: Botões para exportar em CSV ou XLSX
  \item \textbf{Cards de resumo}: Totais de receitas, gastos e saldo do período
\end{itemize}

\subsection{Tipos de Relatórios}

\subsubsection*{Visualizações Implementadas}
\begin{enumerate}
  \item \textbf{Gráfico de Pizza}: Gastos por categoria com percentuais
  \item \textbf{Gráfico de Linha}: Evolução mensal de receitas vs gastos (últimos 12 meses)
  \item \textbf{Gráfico de Barras}: Gastos por conta bancária
  \item \textbf{Lista}: Top 5 maiores gastos do período
\end{enumerate}

\subsubsection*{Períodos Disponíveis}
\begin{itemize}
  \item \textbf{Mensal}: Dados do mês atual
  \item \textbf{Anual}: Dados do ano atual
  \item \textbf{Personalizado}: Usuário define início e fim
\end{itemize}

\subsection{Exportação de Dados}

\subsubsection*{Formatos Suportados}
\begin{itemize}
  \item \textbf{CSV}: Formato de planilha simples, compatível com Excel
  \item \textbf{XLSX}: Formato Excel nativo (simulado com separadores de tabulação)
\end{itemize}

\subsubsection*{Dados Exportados}
\begin{itemize}
  \item Tipo de transação (Gasto/Receita)
  \item Descrição da transação
  \item Valor monetário
  \item Data da transação
  \item Categoria(ies) associada(s)
  \item Conta bancária utilizada
  \item Observações (quando existirem)
\end{itemize}

\subsection{Análise de Dados}

O sistema realiza análises automáticas dos dados financeiros:

\begin{itemize}
  \item \textbf{Totais por período}: Soma de receitas, gastos e saldo
  \item \textbf{Análise por categoria}: Distribuição percentual dos gastos
  \item \textbf{Análise por conta}: Gastos por conta bancária
  \item \textbf{Evolução temporal}: Tendências mensais dos últimos 12 meses
  \item \textbf{Top gastos}: Maiores despesas do período para identificação de padrões
\end{itemize}

\section{Repositório do Projeto}

O código-fonte completo do projeto está disponível publicamente no GitHub:

\begin{center}
\url{https://github.com/marcoslaine/controle-se}
\end{center}

\noindent O repositório contém:
\begin{itemize}
  \item Código-fonte Java completo (estruturas de dados, servidor, banco de dados)
  \item Interface web (HTML, CSS, JavaScript)
  \item Documentação técnica e diagramas
  \item Instruções de compilação e execução
  \item Exemplos de uso e testes
  \item Sistema completo de relatórios com dashboards e exportação
\end{itemize}

\section*{Questionário Técnico - Fase II}

\textbf{a) Qual a estrutura usada para representar os registros?}

Os registros são armazenados em disco usando a seguinte estrutura:

\begin{itemize}
  \item \textbf{Formato}: Arquivos binários \texttt{.db} usando serialização Java nativa
  \item \textbf{Organização}: Um arquivo por entidade (usuarios.db, gastos.db, categorias.db, etc.)
  \item \textbf{Estrutura interna}: Cada arquivo contém uma lista serializada de objetos Java
  \item \textbf{Classes}: Implementam interface \texttt{Serializable} com campos específicos:
    \begin{itemize}
      \item \texttt{Usuario}: id, nome, email, senha, ativo
      \item \texttt{Gasto}: id, idUsuario, valor, descricao, data, observacoes[], ativo
      \item \texttt{Categoria}: id, idUsuario, nome, cor, ativo
      \item \texttt{Tag}: id, idUsuario, nome, cor, ativo
    \end{itemize}
  \item \textbf{Persistência}: Carregamento completo do arquivo na memória, modificação e reescrita
  \item \textbf{Índices}: Mantidos em arquivos separados para busca eficiente (Hash Extensível e B+ Tree)
\end{itemize}

\textbf{b) Como atributos multivalorados do tipo string foram tratados?}

Atributos multivalorados do tipo string foram implementados de duas formas:
\begin{itemize}
  \item \textbf{Nativo}: Campo \texttt{observacoes} na classe \texttt{Gasto} como \texttt{String[]}
  \item \textbf{Simulado via relacionamento N:N}: Categorias de um gasto e tags de uma transação através de tabelas de relacionamento (\texttt{CategoriaGasto} e \texttt{TransacaoTag})
\end{itemize}

\textbf{c) Como foi implementada a exclusão lógica?}

A exclusão lógica foi implementada através do campo booleano \texttt{ativo} presente em todas as entidades. Quando um registro é "excluído", o campo \texttt{ativo} é definido como \texttt{false}, mas o registro permanece no banco de dados. As consultas filtram apenas registros com \texttt{ativo = true}.

\textbf{d) Além das PKs, quais outras chaves foram utilizadas nesta etapa?}

Além das chaves primárias (IDs), foram utilizadas:
\begin{itemize}
  \item \textbf{Chaves estrangeiras}: \texttt{idUsuario} em todas as entidades principais
  \item \textbf{Chaves de relacionamento}: \texttt{idCategoria}, \texttt{idGasto}, \texttt{idTag}, \texttt{idTransacao}
  \item \textbf{Chaves de busca}: \texttt{email} (usuários), \texttt{nome} (categorias, contas, tags)
\end{itemize}

\textbf{e) Quais tipos de estruturas foram utilizadas para cada chave de pesquisa?}

\begin{itemize}
  \item \textbf{Árvore B+ (ordem 4)}: Todas as chaves primárias (IDs) e chaves de busca principais
  \item \textbf{Hash Extensível (3 registros/bucket)}: Relacionamentos 1:N e N:N, índices secundários
  \item \textbf{Índices primários}: Usuários, Categorias, Gastos, Receitas, Contas, Orçamentos, Tags
  \item \textbf{Índices secundários}: Relacionamentos categoria-gasto, tag-transação, usuário-entidades
\end{itemize}

\textbf{f) Como foi implementado o relacionamento 1:N?}

Os relacionamentos 1:N foram implementados através de:
\begin{itemize}
  \item \textbf{Chave estrangeira}: Campo \texttt{idUsuario} em todas as entidades dependentes
  \item \textbf{Navegação}: Busca por \texttt{idUsuario} para recuperar registros relacionados
  \item \textbf{Integridade referencial}: Validação de existência do usuário antes de inserir registros dependentes
  \item \textbf{Exclusão em cascata}: Ao excluir usuário, todos os registros dependentes são marcados como inativos
\end{itemize}

\textbf{g) Como os índices são persistidos em disco?}

\begin{itemize}
  \item \textbf{Formato}: Serialização Java nativa (\texttt{.db} files)
  \item \textbf{Atualização}: Índices são atualizados imediatamente após cada operação de escrita
  \item \textbf{Sincronização}: Salvamento automático após cada modificação (insert, update, delete)
  \item \textbf{Estrutura}: Cada índice é um arquivo separado (ex: \texttt{idx\_usuarios.db}, \texttt{idx\_categorias.db})
  \item \textbf{Verificação de Integridade}: O sistema verifica a existência de todos os índices primários (7 arquivos) e índices secundários essenciais (6 arquivos) antes do carregamento. Se algum índice primário estiver faltando, o sistema força a reconstrução completa dos índices a partir dos dados persistidos, garantindo consistência.
  \item \textbf{Carregamento Inteligente}: Na inicialização, o sistema verifica se os arquivos de índice existem. Se existirem, carrega os índices diretamente dos arquivos. Caso contrário, reconstrói os índices a partir dos dados e os salva para uso futuro.
\end{itemize}

\textbf{h) Como está estruturado o projeto no GitHub?}

\begin{itemize}
  \item \textbf{src/}: Código-fonte Java (classes principais, handlers, utilitários)
  \item \textbf{data/}: Arquivos de banco de dados (\texttt{.db})
  \item \textbf{docs/}: Documentação técnica (LaTeX, diagramas)
  \item \textbf{Raiz}: Arquivos frontend (\texttt{index.html}, \texttt{styles.css}, \texttt{app.js})
  \item \textbf{Arquitetura}: Frontend Web + Backend Java + Banco de Dados Customizado
  \item \textbf{Módulos}: Separação clara entre lógica de negócio, persistência e interface
\end{itemize}

\newpage
\part*{Fase III}
\addcontentsline{toc}{part}{Fase III}

\section{Relacionamentos N:N}

\subsection{Implementação dos Relacionamentos Muitos-para-Muitos}

O sistema implementa dois relacionamentos N:N principais através de tabelas de junção, permitindo que múltiplas entidades se relacionem de forma flexível e eficiente.

\subsubsection*{Categoria $\leftrightarrow$ Gasto (N:N)}
\begin{itemize}
  \item \textbf{Tabela de Junção}: \texttt{CategoriaGasto}
  \item \textbf{Chaves}: \texttt{idCategoriaGasto} (PK), \texttt{idCategoria} (FK), \texttt{idGasto} (FK)
  \item \textbf{Propósito}: Permitir que um gasto tenha múltiplas categorias e uma categoria possa estar associada a múltiplos gastos
  \item \textbf{Implementação}: Hash Extensível para indexação bidirecional eficiente
  \item \textbf{Índices}: 
    \begin{itemize}
      \item \texttt{indiceCategoriaGastos}: Categoria → Lista<CategoriaGasto>
      \item \texttt{indiceGastoCategorias}: Gasto → Lista<CategoriaGasto>
    \end{itemize}
\end{itemize}

\subsubsection*{Tag $\leftrightarrow$ Transação (N:N)}
\begin{itemize}
  \item \textbf{Tabela de Junção}: \texttt{TransacaoTag}
  \item \textbf{Chaves}: \texttt{idTransacaoTag} (PK), \texttt{idTransacao} (FK), \texttt{tipoTransacao} ("GASTO" ou "RECEITA"), \texttt{idTag} (FK)
  \item \textbf{Propósito}: Sistema de tags personalizáveis que permite múltiplas tags por transação (gasto ou receita)
  \item \textbf{Implementação}: Hash Extensível para indexação bidirecional eficiente
  \item \textbf{Índices}:
    \begin{itemize}
      \item \texttt{indiceTagGastos}: Tag → Lista<Gasto>
      \item \texttt{indiceGastoTags}: Gasto → Lista<Tag>
      \item \texttt{indiceTagReceitas}: Tag → Lista<Receita>
      \item \texttt{indiceReceitaTags}: Receita → Lista<Tag>
    \end{itemize}
\end{itemize}

\subsection{Estruturas de Dados para N:N}

\subsubsection*{Hash Extensível para Relacionamentos}
\begin{itemize}
  \item \textbf{Capacidade por bucket}: 3 registros
  \item \textbf{Chave de indexação}: ID da entidade (categoria, gasto, tag ou transação)
  \item \textbf{Valor armazenado}: Objeto de relacionamento (\texttt{CategoriaGasto} ou \texttt{TransacaoTag}) ou ID da entidade relacionada
  \item \textbf{Operações}: Inserção, busca e remoção de relacionamentos
  \item \textbf{Complexidade}: O(1) médio para operações de relacionamento
  \item \textbf{Crescimento dinâmico}: Diretório duplica automaticamente quando necessário
\end{itemize}

\subsection{Operações Implementadas}

\subsubsection*{Relacionamento Categoria-Gasto}

\textbf{Inserção de Relacionamento:}
\begin{itemize}
  \item \texttt{adicionarCategoriaAoGasto(idCategoria, idGasto)}: Cria novo relacionamento N:N
  \item \texttt{adicionarCategoriaAoGastoSemSalvar()}: Versão otimizada sem persistência imediata
  \item Validação automática da existência das entidades antes de criar relacionamento
  \item Atualização automática dos índices bidirecionais
\end{itemize}

\textbf{Busca de Relacionamentos:}
\begin{itemize}
  \item \texttt{buscarGastosPorCategoria(idCategoria)}: Retorna todos os gastos de uma categoria — O(1) médio + O(k) onde k = número de gastos
  \item \texttt{buscarCategoriasDoGasto(idGasto)}: Retorna todas as categorias de um gasto — O(1) médio + O(k) onde k = número de categorias
  \item \texttt{gastoTemCategoria(idGasto, idCategoria)}: Verifica se um gasto possui uma categoria específica — O(1) médio
\end{itemize}

\textbf{Remoção de Relacionamento:}
\begin{itemize}
  \item \texttt{removerCategoriaDoGasto(idCategoria, idGasto)}: Exclusão lógica do relacionamento
  \item Campo \texttt{ativo = false} mantém histórico dos dados
  \item Persistência automática após remoção
\end{itemize}

\subsubsection*{Relacionamento Tag-Transação}

\textbf{Inserção de Relacionamento:}
\begin{itemize}
  \item \texttt{associarTagTransacao(idTransacao, tipoTransacao, idTag)}: Associa tag a gasto ou receita
  \item Suporte para tipos "GASTO" e "RECEITA"
  \item Atualização automática dos índices específicos por tipo
\end{itemize}

\textbf{Busca de Relacionamentos:}
\begin{itemize}
  \item \texttt{buscarTagsGasto(idGasto)}: Retorna todas as tags de um gasto — O(1) médio + O(k)
  \item \texttt{buscarTagsReceita(idReceita)}: Retorna todas as tags de uma receita — O(1) médio + O(k)
  \item \texttt{buscarGastosPorTag(idTag)}: Retorna todos os gastos com uma tag específica — O(1) médio + O(k)
  \item \texttt{buscarReceitasPorTag(idTag)}: Retorna todas as receitas com uma tag específica — O(1) médio + O(k)
\end{itemize}

\subsection{Persistência dos Relacionamentos N:N}

\subsubsection*{Arquivos de Persistência}
\begin{itemize}
  \item \texttt{data/categoria\_gasto.db}: Armazena todos os relacionamentos Categoria-Gasto
  \item \texttt{data/transacao\_tag.db}: Armazena todos os relacionamentos Tag-Transação
  \item \textbf{Formato}: Serialização Java nativa (\texttt{ObjectOutputStream})
  \item \textbf{Estrutura}: Lista de objetos \texttt{CategoriaGasto} ou \texttt{TransacaoTag}
\end{itemize}

\subsubsection*{Estratégia de Persistência}
\begin{itemize}
  \item \textbf{Salvamento}: Após cada operação de escrita (inserção, remoção)
  \item \textbf{Carregamento}: Automático na inicialização do servidor
  \item \textbf{Verificação de Índices}: O sistema verifica a integridade dos índices Hash Extensível antes do carregamento. Se os índices existirem, são carregados diretamente. Caso contrário, são reconstruídos a partir dos relacionamentos persistidos.
  \item \textbf{Reconstrução de índices}: Os índices Hash Extensível são reconstruídos a partir dos relacionamentos carregados quando necessário, garantindo sincronização entre dados e índices.
  \item \textbf{Exclusão lógica}: Relacionamentos marcados como \texttt{ativo = false} são mantidos no arquivo mas não aparecem nas consultas
\end{itemize}

\subsection{Operações de Navegação}

\subsubsection*{Navegação Bidirecional}
O sistema permite navegação eficiente em ambas as direções dos relacionamentos N:N:

\begin{itemize}
  \item \textbf{Categoria → Gastos}: Dada uma categoria, encontrar todos os gastos associados
  \item \textbf{Gasto → Categorias}: Dado um gasto, encontrar todas as categorias associadas
  \item \textbf{Tag → Transações}: Dada uma tag, encontrar todas as transações (gastos e receitas) associadas
  \item \textbf{Transação → Tags}: Dada uma transação, encontrar todas as tags associadas
\end{itemize}

\subsubsection*{Filtros Combinados}
O sistema suporta filtros combinados que utilizam os relacionamentos N:N:

\begin{itemize}
  \item \texttt{buscarGastosComFiltros(idUsuario, idCategoria, data)}: Combina filtro por categoria (via N:N) com filtro por data
  \item Validação de relacionamento através do método \texttt{gastoTemCategoria()}
  \item Complexidade: O(n) onde n = número de gastos do usuário, com verificação O(1) por gasto
\end{itemize}

\subsection{Integridade Referencial}

\subsubsection*{Validações Implementadas}
\begin{itemize}
  \item \textbf{Validação de existência}: Verificação de existência das entidades antes de criar relacionamentos
  \item \textbf{Validação de estado}: Apenas entidades ativas (\texttt{ativo = true}) podem ser relacionadas
  \item \textbf{Prevenção de duplicatas}: Sistema permite múltiplas categorias/tags por gasto, mas evita relacionamentos duplicados
\end{itemize}

\subsubsection*{Exclusão em Cascata}
\begin{itemize}
  \item \textbf{Exclusão de entidade}: Quando uma categoria, gasto ou tag é excluída (lógica), os relacionamentos permanecem mas não aparecem nas consultas
  \item \textbf{Manutenção de histórico}: Relacionamentos antigos são preservados para análise histórica
  \item \textbf{Consistência}: Os índices são atualizados automaticamente para refletir exclusões lógicas
\end{itemize}

\subsection{Interface de Usuário para N:N}

\subsubsection*{Seleção Múltipla de Categorias}
\begin{itemize}
  \item \textbf{Checkboxes}: Interface web com checkboxes para seleção de múltiplas categorias em gastos
  \item \textbf{Validação}: Pelo menos uma categoria deve ser selecionada ao criar um gasto
  \item \textbf{Persistência}: Salvamento automático dos relacionamentos criados via API REST
  \item \textbf{Exibição}: Gastos exibem todas as categorias associadas na interface
\end{itemize}

\subsubsection*{Sistema de Tags}
\begin{itemize}
  \item \textbf{Criação e associação}: Tags podem ser criadas e associadas a transações via interface web
  \item \textbf{Associação múltipla}: Uma transação pode ter múltiplas tags simultaneamente
  \item \textbf{Filtros visuais}: Interface permite filtrar transações por tags específicas
  \item \textbf{Badges coloridos}: Tags são exibidas como badges coloridos para identificação visual rápida
  \item \textbf{Gerenciamento}: CRUD completo de tags com interface dedicada
\end{itemize}

\subsection{Análise de Complexidade}

\begin{table}[H]
\centering
\small
\begin{tabular}{|l|c|c|}
\hline
\textbf{Operação} & \textbf{Estrutura} & \textbf{Complexidade} \\
\hline
Adicionar relacionamento Categoria-Gasto & Hash Extensível & O(1) médio \\
Buscar gastos por categoria & Hash Extensível & O(1) médio + O(k) \\
Buscar categorias de um gasto & Hash Extensível & O(1) médio + O(k) \\
Remover relacionamento & Hash Extensível & O(1) médio + O(k) \\
Associar tag a transação & Hash Extensível & O(1) médio \\
Buscar tags de uma transação & Hash Extensível & O(1) médio + O(k) \\
Filtro combinado (categoria + data) & Hash + Árvore B+ & O(n) onde n = gastos do usuário \\
\hline
\end{tabular}
\caption{Complexidade temporal das operações de relacionamento N:N. k = número de registros retornados.}
\end{table}

\subsection{Benefícios dos Relacionamentos N:N}

\begin{itemize}
  \item \textbf{Flexibilidade}: Categorização múltipla permite análise mais detalhada e precisa dos gastos
  \item \textbf{Organização}: Sistema de tags oferece categorização personalizada além das categorias tradicionais
  \item \textbf{Escalabilidade}: Estruturas Hash Extensível suportam grandes volumes de dados com complexidade O(1) médio
  \item \textbf{Usabilidade}: Interface intuitiva para gerenciamento de relacionamentos múltiplos
  \item \textbf{Performance}: Busca eficiente através de índices bidirecionais
  \item \textbf{Integridade}: Validações automáticas garantem consistência dos dados
\end{itemize}

\subsection{Exemplos de Uso}

\subsubsection*{Criação de Gasto com Múltiplas Categorias}
Ao registrar um gasto, o sistema permite associar múltiplas categorias. Por exemplo, um gasto de "Supermercado" pode ser categorizado como "Alimentação" e "Casa" simultaneamente, permitindo análises mais flexíveis.

\subsubsection*{Sistema de Tags para Organização}
Tags permitem organização adicional além das categorias. Por exemplo, uma receita pode ter tags como "Salário", "Freelance" e "Urgente", facilitando filtros e análises personalizadas.

\subsubsection*{Filtros Avançados}
O sistema permite combinar filtros por categoria (via relacionamento N:N) com outros critérios como data, permitindo consultas complexas de forma eficiente.

\section*{Questionário Técnico - Fase III}

\textbf{1. Qual foi o relacionamento N:N escolhido e quais tabelas ele conecta?}

O sistema implementa dois relacionamentos N:N principais:

\begin{itemize}
  \item \textbf{Categoria $\leftrightarrow$ Gasto (N:N)}: Conecta as tabelas \texttt{Categoria} e \texttt{Gasto} através da tabela intermediária \texttt{CategoriaGasto}. Este relacionamento permite que um gasto tenha múltiplas categorias e que uma categoria possa estar associada a múltiplos gastos.
  \item \textbf{Tag $\leftrightarrow$ Transação (N:N)}: Conecta as tabelas \texttt{Tag} e \texttt{Transação} (que pode ser \texttt{Gasto} ou \texttt{Receita}) através da tabela intermediária \texttt{TransacaoTag}. Este relacionamento permite que uma transação tenha múltiplas tags e que uma tag possa estar associada a múltiplas transações.
\end{itemize}

O relacionamento principal escolhido para a Fase III é o \textbf{Categoria $\leftrightarrow$ Gasto}, que é o relacionamento N:N fundamental do sistema, permitindo categorização múltipla e flexível dos gastos.

\textbf{2. Qual estrutura de índice foi utilizada (B+ ou Hash Extensível)? Justifique a escolha.}

Foi utilizada a estrutura \textbf{Hash Extensível} para indexar os relacionamentos N:N. A justificativa para esta escolha é:

\begin{itemize}
  \item \textbf{Complexidade de busca}: Hash Extensível oferece O(1) médio para busca, inserção e remoção, enquanto Árvore B+ oferece O(log n). Para relacionamentos N:N, onde as buscas são frequentes e não requerem ordenação, o Hash Extensível é mais eficiente.
  \item \textbf{Natureza das consultas}: As consultas em relacionamentos N:N são tipicamente por igualdade (buscar todos os gastos de uma categoria, buscar todas as categorias de um gasto), não por intervalo ou ordenação, o que favorece o uso de hash.
  \item \textbf{Navegação bidirecional}: O Hash Extensível permite criar índices bidirecionais eficientes (categoria → gastos e gasto → categorias) sem duplicação excessiva de dados.
  \item \textbf{Crescimento dinâmico}: O Hash Extensível cresce dinamicamente conforme necessário, adaptando-se ao volume de relacionamentos sem necessidade de rebalanceamento complexo.
  \item \textbf{Performance em operações frequentes}: Como os relacionamentos N:N são consultados frequentemente durante filtros e navegação, o O(1) médio do Hash Extensível oferece melhor performance prática.
\end{itemize}

\textbf{3. Como foi implementada a chave composta da tabela intermediária?}

A chave composta da tabela intermediária \texttt{CategoriaGasto} foi implementada da seguinte forma:

\begin{itemize}
  \item \textbf{Chave primária}: \texttt{idCategoriaGasto} (PK) — ID auto-incremental único para cada relacionamento
  \item \textbf{Chaves estrangeiras}: 
    \begin{itemize}
      \item \texttt{idCategoria} (FK) — Referência à tabela \texttt{Categoria}
      \item \texttt{idGasto} (FK) — Referência à tabela \texttt{Gasto}
    \end{itemize}
  \item \textbf{Implementação}: A combinação \texttt{(idCategoria, idGasto)} forma uma chave composta lógica que identifica unicamente cada relacionamento. Embora não seja uma constraint física no código, a validação é feita através de métodos que verificam a existência de relacionamentos duplicados antes de criar novos.
  \item \textbf{Índices}: Os índices Hash Extensível são criados usando \texttt{idCategoria} e \texttt{idGasto} separadamente, permitindo busca eficiente em ambas as direções:
    \begin{itemize}
      \item \texttt{indiceCategoriaGastos}: Usa \texttt{idCategoria} como chave
      \item \texttt{indiceGastoCategorias}: Usa \texttt{idGasto} como chave
    \end{itemize}
  \item \textbf{Campo adicional}: \texttt{ativo} (boolean) para exclusão lógica, permitindo manter histórico dos relacionamentos
\end{itemize}

\textbf{4. Como é feita a busca eficiente de registros por meio do índice?}

A busca eficiente é realizada através dos índices Hash Extensível bidirecionais:

\begin{itemize}
  \item \textbf{Busca por categoria}: Para encontrar todos os gastos de uma categoria específica:
    \begin{itemize}
      \item Utiliza o índice \texttt{indiceCategoriaGastos} com a chave \texttt{idCategoria}
      \item O Hash Extensível calcula o hash de \texttt{idCategoria} e acessa diretamente o bucket correspondente — O(1) médio
      \item Retorna a lista de objetos \texttt{CategoriaGasto} associados àquela categoria
      \item Filtra apenas relacionamentos com \texttt{ativo = true}
      \item Para cada relacionamento ativo, busca o \texttt{Gasto} correspondente na Árvore B+ usando \texttt{idGasto} — O(log n)
    \end{itemize}
  \item \textbf{Busca por gasto}: Para encontrar todas as categorias de um gasto específico:
    \begin{itemize}
      \item Utiliza o índice \texttt{indiceGastoCategorias} com a chave \texttt{idGasto}
      \item O Hash Extensível calcula o hash de \texttt{idGasto} e acessa diretamente o bucket — O(1) médio
      \item Retorna a lista de objetos \texttt{CategoriaGasto} associados àquele gasto
      \item Filtra relacionamentos ativos e busca as categorias correspondentes na Árvore B+ — O(log n) por categoria
    \end{itemize}
  \item \textbf{Complexidade total}: $O(1)$ médio para acessar o índice + $O(k)$ onde $k$ = número de relacionamentos retornados + $O(k \times \log n)$ para buscar as entidades relacionadas na Árvore B+
  \item \textbf{Vantagem}: O Hash Extensível elimina a necessidade de percorrer todos os relacionamentos, acessando diretamente os relevantes através do hash
\end{itemize}

\textbf{5. Como o sistema trata a integridade referencial (remoção/atualização) entre as tabelas?}

O sistema trata a integridade referencial através de exclusão lógica e validações:

\begin{itemize}
  \item \textbf{Exclusão lógica (Lápide)}:
    \begin{itemize}
      \item Quando uma \texttt{Categoria} ou \texttt{Gasto} é excluído, o campo \texttt{ativo} é marcado como \texttt{false}
      \item Os relacionamentos \texttt{CategoriaGasto} permanecem no banco de dados, mas são filtrados nas consultas
      \item Relacionamentos com entidades inativas não aparecem nos resultados de busca
      \item Isso mantém o histórico e permite recuperação de dados se necessário
    \end{itemize}
  \item \textbf{Validação antes de criar relacionamento}:
    \begin{itemize}
      \item Antes de criar um relacionamento N:N, o sistema verifica se ambas as entidades existem e estão ativas
      \item Método \texttt{buscarCategoria(idCategoria)} e \texttt{buscarGasto(idGasto)} são chamados para validar existência
      \item Apenas entidades com \texttt{ativo = true} podem ser relacionadas
    \end{itemize}
  \item \textbf{Remoção de relacionamento}:
    \begin{itemize}
      \item Método \texttt{removerCategoriaDoGasto()} marca o relacionamento como \texttt{ativo = false}
      \item O relacionamento permanece no arquivo mas não aparece nas consultas
      \item Os índices são atualizados automaticamente ao salvar
    \end{itemize}
  \item \textbf{Atualização de entidades}:
    \begin{itemize}
      \item Atualizações em \texttt{Categoria} ou \texttt{Gasto} não afetam os relacionamentos diretamente
      \item Os relacionamentos referenciam apenas os IDs, que permanecem constantes
      \item Se uma entidade for marcada como inativa, os relacionamentos automaticamente deixam de aparecer nas consultas
    \end{itemize}
  \item \textbf{Consistência de índices}:
    \begin{itemize}
      \item Os índices bidirecionais são atualizados simultaneamente ao criar ou remover relacionamentos
      \item Ao carregar do disco, os índices são reconstruídos a partir dos relacionamentos ativos
    \end{itemize}
\end{itemize}

\textbf{6. Como foi organizada a persistência dos dados dessa nova tabela (mesmo padrão de cabeçalho e lápide)?}

A persistência da tabela \texttt{CategoriaGasto} segue o mesmo padrão das outras tabelas do sistema:

\begin{itemize}
  \item \textbf{Arquivo de persistência}: \texttt{data/categoria\_gasto.db}
  \item \textbf{Formato}: Serialização Java nativa usando \texttt{ObjectOutputStream} e \texttt{ObjectInputStream}
  \item \textbf{Estrutura de armazenamento}:
    \begin{itemize}
      \item Lista de objetos \texttt{CategoriaGasto} serializados diretamente
      \item Não há cabeçalho separado — a lista é serializada como um único objeto
      \item Cada objeto \texttt{CategoriaGasto} contém: \texttt{idCategoriaGasto}, \texttt{idCategoria}, \texttt{idGasto} e \texttt{ativo}
    \end{itemize}
  \item \textbf{Exclusão lógica (Lápide)}:
    \begin{itemize}
      \item Campo \texttt{ativo} (boolean) em cada objeto \texttt{CategoriaGasto}
      \item Relacionamentos excluídos são marcados como \texttt{ativo = false} mas permanecem no arquivo
      \item Ao carregar, apenas relacionamentos com \texttt{ativo = true} são considerados nas consultas
      \item Isso mantém histórico completo dos relacionamentos para análise e possível recuperação
    \end{itemize}
  \item \textbf{Salvamento}:
    \begin{itemize}
      \item Método \texttt{salvarCategoriaGasto()} é chamado após cada operação de escrita (inserção, remoção)
      \item Serializa a lista completa de relacionamentos (incluindo inativos) para o arquivo
    \end{itemize}
  \item \textbf{Carregamento}:
    \begin{itemize}
      \item Método \texttt{carregarCategoriaGasto()} é executado automaticamente na inicialização do servidor
      \item Deserializa a lista de relacionamentos do arquivo
      \item Reconstrói os índices Hash Extensível inserindo todos os relacionamentos (ativos e inativos)
      \item As consultas filtram apenas relacionamentos ativos durante a execução
    \end{itemize}
  \item \textbf{Contador de IDs}: O contador \texttt{proximoIdCategoriaGasto} é salvo em \texttt{data/contadores.db} junto com os outros contadores
\end{itemize}

\textbf{7. Descreva como o código da tabela intermediária se integra com o CRUD das tabelas principais.}

A tabela intermediária \texttt{CategoriaGasto} se integra com o CRUD das tabelas principais da seguinte forma:

\begin{itemize}
  \item \textbf{CREATE (Criação de Gasto)}:
    \begin{itemize}
      \item No método \texttt{cadastrarGasto()}, após inserir o gasto na Árvore B+, o sistema recebe uma lista de IDs de categorias
      \item Para cada categoria na lista, chama \texttt{adicionarCategoriaAoGastoSemSalvar()} que:
        \begin{itemize}
          \item Valida se a categoria existe e está ativa
          \item Cria um novo objeto \texttt{CategoriaGasto} com ID auto-incremental
          \item Adiciona à lista \texttt{relacionamentosCategoriaGasto}
          \item Atualiza os índices bidirecionais (\texttt{indiceCategoriaGastos} e \texttt{indiceGastoCategorias})
        \end{itemize}
      \item Após criar todos os relacionamentos, chama \texttt{salvarCategoriaGasto()} uma única vez para persistir
    \end{itemize}
  \item \textbf{READ (Leitura de Gastos e Categorias)}:
    \begin{itemize}
      \item Ao buscar um gasto, o método \texttt{buscarCategoriasDoGasto(idGasto)} é chamado para retornar todas as categorias associadas
      \item Utiliza o índice \texttt{indiceGastoCategorias} para buscar relacionamentos — O(1) médio
      \item Filtra relacionamentos ativos e busca as categorias correspondentes na Árvore B+
      \item Similarmente, \texttt{buscarGastosPorCategoria(idCategoria)} retorna todos os gastos de uma categoria
    \end{itemize}
  \item \textbf{UPDATE (Atualização)}:
    \begin{itemize}
      \item Atualizações em \texttt{Categoria} ou \texttt{Gasto} não modificam diretamente os relacionamentos
      \item Os relacionamentos referenciam apenas IDs, que permanecem constantes
      \item Se necessário adicionar/remover categorias de um gasto existente, métodos específicos são chamados:
        \begin{itemize}
          \item \texttt{adicionarCategoriaAoGasto()} para adicionar nova categoria
          \item \texttt{removerCategoriaDoGasto()} para remover categoria (exclusão lógica)
        \end{itemize}
    \end{itemize}
  \item \textbf{DELETE (Exclusão Lógica)}:
    \begin{itemize}
      \item Quando um \texttt{Gasto} é excluído (lógica), os relacionamentos permanecem mas não aparecem nas consultas
      \item Quando uma \texttt{Categoria} é excluída (lógica), os relacionamentos permanecem mas não aparecem nas consultas
      \item O método \texttt{removerCategoriaDoGasto()} marca um relacionamento específico como inativo
      \item Todos os métodos de busca filtram relacionamentos com \texttt{ativo = false}
    \end{itemize}
  \item \textbf{Integração com API REST}:
    \begin{itemize}
      \item O endpoint \texttt{POST /api/expenses} recebe \texttt{categoryIds} como array
      \item O handler chama \texttt{cadastrarGasto()} que internamente cria os relacionamentos N:N
      \item Ao retornar gastos via \texttt{GET /api/transactions}, o sistema inclui as categorias associadas usando \texttt{buscarCategoriasDoGasto()}
    \end{itemize}
  \item \textbf{Sincronização}:
    \begin{itemize}
      \item Todas as operações que modificam relacionamentos chamam \texttt{salvarCategoriaGasto()} para persistir
      \item Os índices são atualizados imediatamente após cada modificação
      \item A persistência garante que os dados sejam mantidos entre execuções do servidor
    \end{itemize}
\end{itemize}

\textbf{8. Descreva como está organizada a estrutura de diretórios e módulos no repositório após esta fase.}

Após a implementação da Fase III, a estrutura de diretórios e módulos do repositório está organizada da seguinte forma:

\begin{itemize}
  \item \textbf{src/} — Código-fonte Java:
    \begin{itemize}
      \item \texttt{BancoDados.java}: Classe principal que gerencia todas as tabelas, índices e relacionamentos N:N
      \item \texttt{Entidades.java}: Contém as classes de domínio, incluindo \texttt{CategoriaGasto} e \texttt{TransacaoTag}
      \item \texttt{ArvoreBPlus.java}: Implementação da Árvore B+ para índices primários
      \item \texttt{HashExtensivel.java}: Implementação do Hash Extensível para índices secundários e relacionamentos N:N
      \item \texttt{ControleSeServer.java}: Servidor HTTP com API REST e handlers para todas as operações
      \item \texttt{server/handlers/}: Handlers modulares para diferentes endpoints (CategoriesHandler, AccountsHandler, etc.)
      \item \texttt{server/utils/}: Utilitários (JsonUtil, RequestUtil, ResponseUtil)
    \end{itemize}
  \item \textbf{data/} — Arquivos de persistência:
    \begin{itemize}
      \item \texttt{usuarios.db}, \texttt{categorias.db}, \texttt{gastos.db}, \texttt{receitas.db}, \texttt{contas.db}, \texttt{orcamentos.db}, \texttt{tags.db}: Tabelas principais
      \item \texttt{categoria\_gasto.db}: Tabela intermediária para relacionamento N:N Categoria-Gasto
      \item \texttt{transacao\_tag.db}: Tabela intermediária para relacionamento N:N Tag-Transação
      \item \texttt{contadores.db}: Contadores de IDs auto-incrementais (incluindo \texttt{proximoIdCategoriaGasto} e \texttt{proximoIdTransacaoTag})
    \end{itemize}
  \item \textbf{docs/} — Documentação:
    \begin{itemize}
      \item \texttt{main.tex}: Fonte LaTeX da documentação completa (Fases I, II e III)
      \item \texttt{der.png}, \texttt{caso.png}: Diagramas do projeto
      \item PDFs das especificações de cada fase
    \end{itemize}
  \item \textbf{Raiz do projeto}:
    \begin{itemize}
      \item \texttt{index.html}, \texttt{styles.css}, \texttt{app.js}: Frontend web completo
      \item \texttt{README.md}: Documentação do projeto com instruções de uso
      \item \texttt{Dockerfile}, \texttt{render.yaml}: Configurações para deploy
    \end{itemize}
  \item \textbf{Organização modular}:
    \begin{itemize}
      \item \textbf{Camada de persistência}: \texttt{BancoDados.java} centraliza todas as operações de banco de dados
      \item \textbf{Camada de entidades}: \texttt{Entidades.java} contém todas as classes de domínio
      \item \textbf{Camada de estruturas}: \texttt{ArvoreBPlus.java} e \texttt{HashExtensivel.java} são estruturas reutilizáveis
      \item \textbf{Camada de API}: \texttt{ControleSeServer.java} e handlers modulares gerenciam requisições HTTP
      \item \textbf{Separação de responsabilidades}: Cada módulo tem responsabilidade clara e bem definida
    \end{itemize}
  \item \textbf{Integração dos relacionamentos N:N}:
    \begin{itemize}
      \item Métodos de relacionamento N:N estão em \texttt{BancoDados.java} na seção "OPERAÇÕES DE RELACIONAMENTO N:N"
      \item Classes \texttt{CategoriaGasto} e \texttt{TransacaoTag} estão em \texttt{Entidades.java}
      \item Índices Hash Extensível para relacionamentos são inicializados em \texttt{BancoDados.java}
      \item Persistência de relacionamentos segue o mesmo padrão das outras tabelas
    \end{itemize}
\end{itemize}

\newpage
\part*{Fase IV}
\addcontentsline{toc}{part}{Fase IV}

\section{Compressão de Dados}

O sistema implementa compressão de dados utilizando dois algoritmos distintos: \textbf{Huffman} e \textbf{LZW}. A compressão é aplicada a nível de arquivo, funcionando como um sistema completo de backup que gera um único arquivo compactado contendo todos os arquivos de dados do sistema.

\subsection{Implementação dos Algoritmos de Compressão}

\subsubsection*{Algoritmo de Huffman}

O algoritmo de Huffman foi implementado utilizando uma \textbf{árvore binária} para representar os códigos de compressão. A estrutura de dados utilizada é:

\begin{itemize}
  \item \textbf{Árvore binária}: Cada nó representa um byte ou um nó interno da árvore
  \item \textbf{PriorityQueue (Heap)}: Utilizada para construir a árvore de Huffman, ordenando nós por frequência
  \item \textbf{HashMap}: Armazena o mapa de frequências de bytes e o mapa de códigos gerados
\end{itemize}

\textbf{Processo de compressão:}
\begin{enumerate}
  \item Calcula a frequência de cada byte no arquivo
  \item Constrói a árvore de Huffman combinando os dois nós com menor frequência
  \item Gera códigos binários para cada byte percorrendo a árvore
  \item Serializa a árvore (necessária para descompressão)
  \item Codifica os dados usando os códigos gerados
  \item Converte a string binária para bytes
\end{enumerate}

\textbf{Formato do arquivo comprimido:}
\begin{itemize}
  \item Tamanho da árvore (4 bytes)
  \item Árvore serializada
  \item Tamanho dos dados codificados (4 bytes)
  \item Dados codificados
  \item Tamanho original em bits (4 bytes)
\end{itemize}

\subsubsection*{Algoritmo LZW (Lempel-Ziv-Welch)}

O algoritmo LZW foi implementado utilizando um \textbf{dicionário dinâmico} que cresce durante a compressão. A estrutura de dados utilizada é:

\begin{itemize}
  \item \textbf{HashMap}: Dicionário que mapeia sequências de bytes para códigos inteiros
  \item \textbf{ArrayList}: Armazena sequências de bytes e códigos de saída
  \item \textbf{Tamanho do dicionário}: 4096 entradas (12 bits por código)
\end{itemize}

\textbf{Processo de compressão:}
\begin{enumerate}
  \item Inicializa dicionário com todos os bytes possíveis (0-255)
  \item Percorre os dados procurando a maior sequência conhecida no dicionário
  \item Emite o código da sequência encontrada
  \item Adiciona nova sequência (sequência atual + próximo byte) ao dicionário
  \item Converte códigos para bytes usando codificação de 12 bits
\end{enumerate}

\textbf{Formato do arquivo comprimido:}
\begin{itemize}
  \item Número de códigos (4 bytes)
  \item Códigos em 12 bits cada
  \item Bits de padding (1 byte)
  \item Informação de padding (1 byte)
\end{itemize}

\subsection{Sistema de Compressão de Arquivos}

A classe \texttt{FileCompressor} gerencia a compressão de todos os arquivos \texttt{.db} do sistema:

\begin{itemize}
  \item \textbf{Arquivos comprimidos}: Todos os arquivos em \texttt{data/} e \texttt{data/idx/}
  \item \textbf{Formato do arquivo}: Um único arquivo contendo todos os arquivos de dados
  \item \textbf{Estrutura do arquivo}: [Número de arquivos][Para cada arquivo: caminho relativo, tamanho, dados]
  \item \textbf{Algoritmos suportados}: LZW e Huffman
  \item \textbf{Extensões}: \texttt{.lzw} para LZW e \texttt{.huffman} para Huffman
  \item \textbf{Localização}: \texttt{data/compressed/lzw/} e \texttt{data/compressed/huffman/}
\end{itemize}

\subsection{Resultados de Compressão}

Com base nos testes realizados com 22 arquivos \texttt{.db} (8 arquivos em \texttt{data/} e 14 arquivos em \texttt{data/idx/}):

\textbf{Algoritmo de Huffman:}
\begin{itemize}
  \item \textbf{Tamanho original}: 2.003.853 bytes
  \item \textbf{Tamanho comprimido}: 646.220 bytes
  \item \textbf{Taxa de compressão}: 67,75\%
  \item \textbf{Redução}: 1.357.633 bytes (aproximadamente 1,3 MB)
\end{itemize}

\textbf{Algoritmo LZW:}
\begin{itemize}
  \item \textbf{Tamanho original}: 2.003.853 bytes
  \item \textbf{Tamanho comprimido}: 406.343 bytes
  \item \textbf{Taxa de compressão}: 79,72\%
  \item \textbf{Redução}: 1.597.510 bytes (aproximadamente 1,5 MB)
\end{itemize}

\textbf{Análise dos resultados:}
\begin{itemize}
  \item O algoritmo LZW obteve melhor taxa de compressão (79,72\%) comparado ao Huffman (67,75\%)
  \item LZW é mais eficiente para dados com padrões repetitivos, como arquivos de banco de dados
  \item Huffman é mais eficiente para dados com distribuição desigual de frequências
  \item Ambos os algoritmos preservam a integridade dos dados após descompressão
\end{itemize}

\subsection{Descompressão e Restauração}

O sistema de descompressão restaura todos os arquivos para suas localizações originais:

\begin{itemize}
  \item \textbf{Detecção automática}: O algoritmo é identificado pela extensão do arquivo (\texttt{.lzw} ou \texttt{.huffman})
  \item \textbf{Restauração completa}: Todos os arquivos são restaurados mantendo a estrutura de diretórios
  \item \textbf{Verificação}: O sistema verifica a integridade dos dados após descompressão
  \item \textbf{Validação}: Tamanho dos arquivos restaurados corresponde ao tamanho original
\end{itemize}

\section{Criptografia RSA}

O sistema implementa criptografia RSA para proteger dados sensíveis, especificamente o campo \textbf{senha} da entidade \texttt{Usuario}. A criptografia é aplicada antes do armazenamento em disco, garantindo que dados sensíveis nunca sejam armazenados em texto plano.

\subsection{Escolha do Campo Criptografado}

O campo escolhido para criptografia foi a \textbf{senha do usuário} (\texttt{Usuario.senha}). A justificativa para esta escolha é:

\begin{itemize}
  \item \textbf{Sensibilidade}: Senhas são informações altamente sensíveis que não devem ser armazenadas em texto plano
  \item \textbf{Segurança}: Proteção contra acesso não autorizado aos dados do sistema
  \item \textbf{Conformidade}: Boas práticas de segurança exigem criptografia de senhas
  \item \textbf{Impacto}: Campo crítico para autenticação e segurança do sistema
\end{itemize}

\subsection{Implementação do RSA}

\subsubsection*{Estrutura das Chaves}

O sistema utiliza chaves RSA com as seguintes características:

\begin{itemize}
  \item \textbf{Tamanho das chaves}: 256 bits (128 bits para cada primo p e q)
  \item \textbf{Expoente público (e)}: 65537 (padrão RSA)
  \item \textbf{Expoente privado (d)}: Calculado usando algoritmo estendido de Euclides
  \item \textbf{Módulo (n)}: Produto de dois números primos grandes ($p \times q$)
  \item \textbf{Função totiente}: $\phi(n) = (p-1) \times (q-1)$
\end{itemize}

\textbf{Justificativa do tamanho das chaves:}
\begin{itemize}
  \item 256 bits oferece segurança adequada para aplicações acadêmicas
  \item Balanceamento entre segurança e performance
  \item Chaves maiores (512+ bits) seriam mais seguras mas mais lentas
  \item 256 bits é suficiente para proteger senhas de usuários
\end{itemize}

\subsubsection*{Geração de Números Primos}

A geração de números primos utiliza o \textbf{teste de Miller-Rabin}:

\begin{itemize}
  \item \textbf{Algoritmo}: Teste probabilístico de primalidade
  \item \textbf{Iterações}: 20 iterações para alta confiança (probabilidade de erro $< 2^{-40}$)
  \item \textbf{Geração}: Números primos de 128 bits cada (p e q)
  \item \textbf{Garantia}: p e q são diferentes e ímpares
\end{itemize}

\subsubsection*{Armazenamento das Chaves}

As chaves RSA são armazenadas da seguinte forma:

\begin{itemize}
  \item \textbf{Arquivo}: \texttt{data/chaves\_rsa.db}
  \item \textbf{Formato}: Serialização Java (ObjectOutputStream)
  \item \textbf{Conteúdo}: Três objetos BigInteger serializados (n, e, d)
  \item \textbf{Segurança}: Arquivo contém chave privada - deve ser protegido em produção
  \item \textbf{Persistência}: Chaves são geradas uma vez e reutilizadas
\end{itemize}

\subsubsection*{Carregamento das Chaves}

O sistema utiliza o padrão \textbf{Singleton} para gerenciar as chaves RSA:

\begin{itemize}
  \item \textbf{Classe}: \texttt{RSAKeyManager}
  \item \textbf{Comportamento}: 
    \begin{itemize}
      \item Se o arquivo \texttt{chaves\_rsa.db} existe, carrega as chaves existentes
      \item Se não existe, gera novas chaves e as salva
      \item Garante que apenas uma instância de RSA é criada
    \end{itemize}
  \item \textbf{Inicialização}: Automática na primeira chamada de \texttt{obterInstancia()}
  \item \textbf{Reutilização}: Mesmas chaves são usadas durante toda a execução do sistema
\end{itemize}

\subsection{Processo de Criptografia e Descriptografia}

\subsubsection*{Criptografia no CRUD (CREATE)}

A criptografia ocorre durante a operação de \textbf{criação de usuário}:

\begin{itemize}
  \item \textbf{Método}: \texttt{cadastrarUsuario(nome, email, senha)}
  \item \textbf{Processo}:
    \begin{enumerate}
      \item Recebe a senha em texto plano
      \item Obtém instância de RSA através de \texttt{RSAKeyManager.obterInstancia()}
      \item Criptografa a senha usando \texttt{rsa.criptografar(senha)}
      \item Armazena a senha criptografada no objeto \texttt{Usuario}
      \item Persiste o usuário no arquivo \texttt{usuarios.db}
    \end{enumerate}
  \item \textbf{Localização no código}: \texttt{BancoDados.java}, linha 229
  \item \textbf{Resultado}: Senha é armazenada em formato hexadecimal criptografado
\end{itemize}

\subsubsection*{Descriptografia no CRUD (READ)}

A descriptografia ocorre durante a operação de \textbf{autenticação de usuário}:

\begin{itemize}
  \item \textbf{Método}: \texttt{autenticarUsuario(email, senha)}
  \item \textbf{Processo}:
    \begin{enumerate}
      \item Busca o usuário pelo email
      \item Obtém a senha criptografada do objeto \texttt{Usuario}
      \item Obtém instância de RSA através de \texttt{RSAKeyManager.obterInstancia()}
      \item Descriptografa a senha usando \texttt{rsa.descriptografar(usuario.getSenha())}
      \item Compara a senha descriptografada com a senha fornecida
    \end{enumerate}
  \item \textbf{Localização no código}: \texttt{BancoDados.java}, linha 272
  \item \textbf{Resultado}: Senha é descriptografada apenas para verificação, nunca retornada ao usuário
\end{itemize}

\subsection{Conversões Realizadas}

O processo de criptografia RSA envolve as seguintes conversões:

\begin{enumerate}
  \item \textbf{String → Bytes}: A senha (String) é convertida para array de bytes usando \texttt{texto.getBytes()}
  \item \textbf{Bytes → BigInteger}: Os bytes são convertidos para BigInteger usando \texttt{new BigInteger(1, bytes)}
  \item \textbf{Criptografia}: Aplicação da fórmula RSA: $c = m^e \bmod n$
  \item \textbf{BigInteger → Hexadecimal}: O resultado criptografado é convertido para string hexadecimal usando \texttt{criptografado.toString(16)}
  \item \textbf{Armazenamento}: String hexadecimal é armazenada no campo \texttt{senha} do objeto \texttt{Usuario}
\end{enumerate}

\textbf{Processo de descriptografia (reverso):}
\begin{enumerate}
  \item \textbf{Hexadecimal → BigInteger}: String hexadecimal é convertida para BigInteger usando \texttt{new BigInteger(textoCriptografado, 16)}
  \item \textbf{Descriptografia}: Aplicação da fórmula RSA: $m = c^d \bmod n$
  \item \textbf{BigInteger → Bytes}: O resultado descriptografado é convertido para array de bytes usando \texttt{descriptografado.toByteArray()}
  \item \textbf{Bytes → String}: Os bytes são convertidos de volta para String usando \texttt{new String(bytes)}
\end{enumerate}

\subsection{Tratamento de Blocos}

Para mensagens maiores que o módulo n, o sistema divide em blocos:

\begin{itemize}
  \item \textbf{Tamanho do bloco}: Calculado como $(n.bitLength() - 1) / 8$ bytes
  \item \textbf{Separação}: Blocos são separados por dois pontos (\texttt{:}) na string hexadecimal
  \item \textbf{Processamento}: Cada bloco é criptografado/descriptografado separadamente
  \item \textbf{Reconstrução}: Blocos são concatenados após descriptografia
\end{itemize}

\subsection{Exponenciação Modular}

A implementação utiliza exponenciação modular eficiente:

\begin{itemize}
  \item \textbf{Algoritmo}: Método de exponenciação binária (square-and-multiply)
  \item \textbf{Otimização}: Reduz complexidade de O(n) para O(log n)
  \item \textbf{Implementação}: Método \texttt{modPow()} na classe \texttt{RSAEncryption}
  \item \textbf{Eficiência}: Essencial para operações com números grandes
\end{itemize}

\section*{Questionário Técnico - Fase IV}

\textbf{1. Qual foi a taxa de compressão obtida com o algoritmo de Huffman?}

\textbf{a) Tamanho do arquivo original:}
\begin{itemize}
  \item 2.003.853 bytes (aproximadamente 1,96 MB)
  \item Composto por 22 arquivos \texttt{.db} (8 arquivos em \texttt{data/} e 14 arquivos em \texttt{data/idx/})
\end{itemize}

\textbf{b) Tamanho do arquivo comprimido:}
\begin{itemize}
  \item 646.220 bytes (aproximadamente 631 KB)
\end{itemize}

\textbf{c) Cálculo da taxa:}
\begin{align*}
\text{Taxa de compressão} &= \left(1 - \frac{\text{Tamanho comprimido}}{\text{Tamanho original}}\right) \times 100\% \\
&= \left(1 - \frac{646220}{2003853}\right) \times 100\% \\
&= \left(1 - 0{,}3225\right) \times 100\% \\
&= 67{,}75\%
\end{align*}

\textbf{d) Interpretação do resultado:}
\begin{itemize}
  \item O algoritmo de Huffman conseguiu reduzir o tamanho dos arquivos em 67,75\%
  \item Redução de 1.357.633 bytes (aproximadamente 1,3 MB)
  \item A compressão é eficaz devido à distribuição desigual de frequências dos bytes nos arquivos de banco de dados
  \item Bytes mais frequentes recebem códigos menores, otimizando o espaço de armazenamento
  \item O overhead da árvore de Huffman serializada é compensado pela eficiência da codificação
\end{itemize}

\textbf{2. Qual foi a taxa de compressão obtida com o algoritmo de LZW?}

\textbf{a) Tamanho do arquivo original:}
\begin{itemize}
  \item 2.003.853 bytes (aproximadamente 1,96 MB)
  \item Mesmo conjunto de 22 arquivos \texttt{.db} usado no teste de Huffman
\end{itemize}

\textbf{b) Tamanho do arquivo comprimido:}
\begin{itemize}
  \item 406.343 bytes (aproximadamente 397 KB)
\end{itemize}

\textbf{c) Cálculo da taxa:}
\begin{align*}
\text{Taxa de compressão} &= \left(1 - \frac{\text{Tamanho comprimido}}{\text{Tamanho original}}\right) \times 100\% \\
&= \left(1 - \frac{406343}{2003853}\right) \times 100\% \\
&= \left(1 - 0{,}2028\right) \times 100\% \\
&= 79{,}72\%
\end{align*}

\textbf{d) Interpretação do resultado:}
\begin{itemize}
  \item O algoritmo LZW obteve melhor desempenho que Huffman, com 79,72\% de compressão
  \item Redução de 1.597.510 bytes (aproximadamente 1,5 MB)
  \item LZW é mais eficiente para dados com padrões repetitivos, como arquivos de banco de dados
  \item O dicionário dinâmico permite identificar e codificar sequências repetidas eficientemente
  \item A codificação de 12 bits por símbolo (4096 entradas no dicionário) oferece boa relação compressão/performance
  \item LZW é particularmente eficaz em dados estruturados como os arquivos \texttt{.db} do sistema
\end{itemize}

\textbf{3. Quais dificuldades surgiram ao implementar Huffman e LZW e como você resolveu?}

\textbf{Dificuldades na implementação de Huffman:}
\begin{itemize}
  \item \textbf{Serialização da árvore}: A árvore de Huffman precisa ser serializada junto com os dados comprimidos para permitir descompressão. \textbf{Solução}: Implementação de métodos \texttt{serializeTree()} e \texttt{deserializeTree()} que percorrem a árvore em pré-ordem, marcando nós folha e internos.
  \item \textbf{Conversão binária}: Strings binárias precisam ser convertidas para bytes e vice-versa. \textbf{Solução}: Implementação de métodos \texttt{binaryStringToBytes()} e \texttt{bytesToBinaryString()} que manipulam bits individualmente.
  \item \textbf{Caso especial de um único byte}: Quando há apenas um tipo de byte no arquivo, a árvore degenera. \textbf{Solução}: Criação de nó auxiliar para garantir que sempre haja pelo menos dois nós na árvore.
  \item \textbf{Padding de bits}: O último byte pode não estar completo. \textbf{Solução}: Armazenamento do tamanho original em bits para descartar bits de padding durante descompressão.
\end{itemize}

\textbf{Dificuldades na implementação de LZW:}
\begin{itemize}
  \item \textbf{Codificação de 12 bits}: Códigos precisam ser armazenados em 12 bits (1,5 bytes), não em múltiplos de 8. \textbf{Solução}: Implementação de buffer de bits que acumula bits até formar bytes completos, com tratamento especial para padding.
  \item \textbf{Caso especial na descompressão}: Quando um código ainda não está no dicionário durante descompressão. \textbf{Solução}: Implementação do caso especial do algoritmo LZW onde o novo código é construído a partir do código anterior.
  \item \textbf{Tamanho do dicionário}: Limitação do dicionário a 4096 entradas para usar 12 bits por código. \textbf{Solução}: Quando o dicionário está cheio, novas sequências não são adicionadas, mas o algoritmo continua funcionando.
  \item \textbf{Conversão de códigos para bytes}: Códigos inteiros precisam ser convertidos para bytes de forma eficiente. \textbf{Solução}: Implementação de métodos \texttt{codesToBytes()} e \texttt{bytesToCodes()} que manipulam bits diretamente.
\end{itemize}

\textbf{4. Justifique a escolha da estrutura de dados usada para armazenar as tabelas, dicionários e árvores utilizados pelos algoritmos.}

\textbf{Algoritmo de Huffman:}
\begin{itemize}
  \item \textbf{PriorityQueue (Heap)}: Utilizada para construir a árvore de Huffman. Justificativa: Permite acesso eficiente aos dois nós com menor frequência em O(log n), essencial para o algoritmo de construção da árvore.
  \item \textbf{Árvore binária (HuffmanNode)}: Estrutura recursiva para representar a árvore. Justificativa: Representação natural da hierarquia de códigos, permite percurso eficiente para geração de códigos e descompressão.
  \item \textbf{HashMap}: Armazena frequências e códigos gerados. Justificativa: Acesso O(1) para consulta de frequências e códigos durante compressão e descompressão.
\end{itemize}

\textbf{Algoritmo LZW:}
\begin{itemize}
  \item \textbf{HashMap}: Dicionário que mapeia sequências de bytes para códigos. Justificativa: Acesso O(1) médio para busca de sequências no dicionário, essencial para eficiência do algoritmo.
  \item \textbf{ArrayList}: Armazena sequências de bytes e códigos de saída. Justificativa: Permite crescimento dinâmico e acesso sequencial eficiente durante compressão e descompressão.
  \item \textbf{\texttt{List<Byte>}}: Representa sequências de bytes no dicionário. Justificativa: Permite comparação e manipulação eficiente de sequências de tamanho variável.
\end{itemize}

\textbf{Justificativa geral:}
\begin{itemize}
  \item As estruturas escolhidas oferecem complexidade temporal adequada para os algoritmos
  \item HashMap e PriorityQueue são estruturas padrão da biblioteca Java, testadas e otimizadas
  \item As estruturas permitem implementação clara e manutenível dos algoritmos
  \item Balanceamento entre eficiência de memória e performance computacional
\end{itemize}

\textbf{5. Qual campo foi escolhido para criptografia? Por quê?}

O campo escolhido para criptografia foi a \textbf{senha do usuário} (\texttt{Usuario.senha}).

\textbf{Justificativa:}
\begin{itemize}
  \item \textbf{Alta sensibilidade}: Senhas são informações altamente sensíveis que não devem ser armazenadas em texto plano sob nenhuma circunstância
  \item \textbf{Segurança do sistema}: A senha é o principal mecanismo de autenticação e controle de acesso ao sistema
  \item \textbf{Proteção de dados}: Em caso de acesso não autorizado aos arquivos de banco de dados, as senhas criptografadas não podem ser utilizadas diretamente
  \item \textbf{Boas práticas}: Criptografia de senhas é uma prática padrão em sistemas de segurança
  \item \textbf{Impacto crítico}: Comprometimento de senhas pode levar a acesso não autorizado a todos os dados financeiros do usuário
  \item \textbf{Conformidade}: Atende requisitos de segurança de dados pessoais e financeiros
\end{itemize}

\textbf{6. Descreva como o RSA foi implementado no projeto.}

\textbf{a) Estrutura das chaves pública e privada:}
\begin{itemize}
  \item \textbf{Chave pública}: Composta por (n, e), onde:
    \begin{itemize}
      \item \textbf{n}: Módulo RSA, produto de dois números primos grandes ($p \times q$)
      \item \textbf{e}: Expoente público, geralmente 65537
    \end{itemize}
  \item \textbf{Chave privada}: Composta por (n, d), onde:
    \begin{itemize}
      \item \textbf{n}: Mesmo módulo da chave pública
      \item \textbf{d}: Expoente privado, calculado como inverso modular de e módulo $\phi(n)$
    \end{itemize}
  \item \textbf{Parâmetros internos}: p, q (números primos) e $\phi(n) = (p-1)(q-1)$ são mantidos apenas durante geração
\end{itemize}

\textbf{b) Como e onde foram armazenadas:}
\begin{itemize}
  \item \textbf{Arquivo}: \texttt{data/chaves\_rsa.db}
  \item \textbf{Formato}: Serialização Java usando \texttt{ObjectOutputStream}
  \item \textbf{Conteúdo}: Três objetos \texttt{BigInteger} serializados na ordem: n, e, d
  \item \textbf{Método}: \texttt{RSAEncryption.salvarChaves(String arquivoChaves)}
  \item \textbf{Persistência}: Chaves são geradas uma vez na primeira execução e reutilizadas
\end{itemize}

\textbf{c) Como foram carregadas pelo sistema:}
\begin{itemize}
  \item \textbf{Classe gerenciadora}: \texttt{RSAKeyManager} implementa padrão Singleton
  \item \textbf{Método}: \texttt{RSAKeyManager.obterInstancia()}
  \item \textbf{Processo}:
    \begin{enumerate}
      \item Verifica se instância já existe (retorna se existir)
      \item Verifica se arquivo \texttt{chaves\_rsa.db} existe
      \item Se existe: carrega chaves usando \texttt{RSAEncryption.carregarChaves()}
      \item Se não existe: gera novas chaves e as salva
      \item Retorna instância única de \texttt{RSAEncryption}
    \end{enumerate}
  \item \textbf{Deserialização}: \texttt{ObjectInputStream} lê os três \texttt{BigInteger} e reconstrói objeto \texttt{RSAEncryption}
\end{itemize}

\textbf{d) Tamanho das chaves escolhidas e justificativa:}
\begin{itemize}
  \item \textbf{Tamanho}: 256 bits (128 bits para cada primo p e q)
  \item \textbf{Justificativa}:
    \begin{itemize}
      \item \textbf{Segurança adequada}: 256 bits oferece segurança suficiente para aplicações acadêmicas e sistemas internos
      \item \textbf{Performance}: Chaves maiores (512+ bits) seriam mais seguras mas significativamente mais lentas
      \item \textbf{Balanceamento}: Equilíbrio entre segurança e eficiência computacional
      \item \textbf{Contexto}: Para proteção de senhas de usuários em sistema acadêmico, 256 bits é apropriado
      \item \textbf{Recomendação}: Em produção, chaves de 2048+ bits seriam recomendadas
    \end{itemize}
\end{itemize}

\textbf{e) Em qual momento a criptografia do(s) campo(s) ocorre (no CRUD):}
\begin{itemize}
  \item \textbf{Operação}: CREATE (Criação de usuário)
  \item \textbf{Método}: \texttt{BancoDados.cadastrarUsuario(String nome, String email, String senha)}
  \item \textbf{Localização no código}: Linha 229 de \texttt{BancoDados.java}
  \item \textbf{Processo}:
    \begin{enumerate}
      \item Método recebe senha em texto plano
      \item Obtém instância RSA: \texttt{RSAEncryption rsa = RSAKeyManager.obterInstancia()}
      \item Criptografa senha: \texttt{String senhaCriptografada = rsa.criptografar(senha)}
      \item Cria objeto \texttt{Usuario} com senha criptografada
      \item Persiste usuário no arquivo \texttt{usuarios.db}
    \end{enumerate}
  \item \textbf{Resultado}: Senha é armazenada em formato hexadecimal criptografado
\end{itemize}

\textbf{f) Em qual momento ocorre a descriptografia:}
\begin{itemize}
  \item \textbf{Operação}: READ (Autenticação de usuário)
  \item \textbf{Método}: \texttt{BancoDados.autenticarUsuario(String email, String senha)}
  \item \textbf{Localização no código}: Linha 272 de \texttt{BancoDados.java}
  \item \textbf{Processo}:
    \begin{enumerate}
      \item Busca usuário pelo email
      \item Obtém senha criptografada do objeto \texttt{Usuario}
      \item Obtém instância RSA: \texttt{RSAEncryption rsa = RSAKeyManager.obterInstancia()}
      \item Descriptografa senha: \texttt{String senhaDescriptografada = rsa.descriptografar(usuario.getSenha())}
      \item Compara senha descriptografada com senha fornecida
      \item Retorna resultado da autenticação
    \end{enumerate}
  \item \textbf{Segurança}: Senha é descriptografada apenas para verificação, nunca retornada ao usuário ou exposta
\end{itemize}

\textbf{g) Conversões realizadas (ex.: string → bytes → blocos):}
\begin{itemize}
  \item \textbf{Processo de criptografia}:
    \begin{enumerate}
      \item \textbf{String → Bytes}: \texttt{byte[] bytes = texto.getBytes()} (codificação UTF-8)
      \item \textbf{Bytes → BigInteger}: \texttt{BigInteger mensagem = new BigInteger(1, bytes)} (conversão com sinal positivo)
      \item \textbf{Verificação de tamanho}: Se mensagem $\geq n$, divide em blocos
      \item \textbf{Criptografia}: \texttt{BigInteger criptografado = modPow(mensagem, e, n)} (fórmula: $c = m^e \bmod n$)
      \item \textbf{BigInteger → Hexadecimal}: \texttt{String hex = criptografado.toString(16)} (representação hexadecimal)
      \item \textbf{Armazenamento}: String hexadecimal é armazenada no campo \texttt{senha}
    \end{enumerate}
  \item \textbf{Processo de descriptografia}:
    \begin{enumerate}
      \item \textbf{Hexadecimal → BigInteger}: \texttt{BigInteger criptografado = new BigInteger(hex, 16)} (parse hexadecimal)
      \item \textbf{Descriptografia}: \texttt{BigInteger descriptografado = modPow(criptografado, d, n)} (fórmula: $m = c^d \bmod n$)
      \item \textbf{BigInteger → Bytes}: \texttt{byte[] bytes = descriptografado.toByteArray()} (conversão para array)
      \item \textbf{Remoção de padding}: Remove byte zero à esquerda se existir (artefato da conversão BigInteger)
      \item \textbf{Bytes → String}: \texttt{String texto = new String(bytes)} (decodificação UTF-8)
    \end{enumerate}
      \item \textbf{Tratamento de blocos} (quando mensagem $> n$):
    \begin{itemize}
      \item \textbf{Divisão}: Mensagem é dividida em blocos de tamanho $(n.bitLength() - 1) / 8$ bytes
      \item \textbf{Criptografia por bloco}: Cada bloco é criptografado separadamente
      \item \textbf{Concatenação}: Blocos criptografados são concatenados com separador \texttt{:}
      \item \textbf{Descriptografia}: Blocos são separados, descriptografados e concatenados
    \end{itemize}
  \item \textbf{Exponenciação modular}: Implementação eficiente usando método square-and-multiply (complexidade O(log n))
\end{itemize}

\end{document}
