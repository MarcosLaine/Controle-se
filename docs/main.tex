\documentclass[12pt,a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[brazil]{babel}
\usepackage{geometry}
\geometry{margin=2.5cm}

\usepackage[final]{graphicx}
\usepackage{float}
\usepackage{caption}
\captionsetup{font=small,labelfont=bf}
\usepackage{hyperref}
\hypersetup{colorlinks=true, linkcolor=black, urlcolor=blue}

\title{Controle-se: Aplicação Web de Controle de Gastos Pessoais\\
\large AED III — Trabalho Prático}
\author{Ana Carolina Couto Machado e Marcos Paulo Da Silva Laine.}
\date{\today}

\begin{document}
\maketitle

\section*{Formulário de Identificação}
\begin{table}[H]
\centering
\begin{tabular}{|l|p{10cm}|}
\hline
\textbf{Disciplina} & Algoritmos e Estruturas de Dados III \\
\hline
\textbf{Professor} & Walisson Ferreira \\
\hline
\textbf{Período} & 2025/1 \\
\hline
\textbf{Alunos} & Ana Carolina Couto Machado e Marcos Paulo Da Silva Laine \\
\hline
\textbf{Título do Projeto} & Controle-se: Aplicação Web de Controle de Gastos Pessoais \\
\hline
\textbf{Data de Entrega} & \today \\
\hline
\textbf{Repositório} & \url{https://github.com/marcoslaine/controle-se} \\
\hline
\end{tabular}
\end{table}

\newpage
\part*{Fase I}
\addcontentsline{toc}{part}{Fase I}

\section{Descrição do Problema e Tema}
O \textbf{Controle-se} é uma aplicação web para controle de gastos pessoais. O sistema permite
registrar \textbf{gastos} e \textbf{receitas}, categorizá-los, gerenciar contas (carteira, banco, cartão),
definir orçamentos mensais por categoria e visualizar indicadores (saldo por conta, execução do orçamento e histórico).

\subsection*{Requisitos}
\begin{itemize}
  \item \textbf{Funcionais}: Definição de orçamento; categorização de gasto; inserção, remoção e edição de gasto; \
  inserção de contas bancárias; visualização geral; visualização de gastos recentes; filtrar gastos por categorias
  \item \textbf{Não funcionais}: dados criptografados; armazenamento local; dados comprimidos;
\end{itemize}

\section{Diagrama de Caso de Uso}
\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth,height=.86\textheight,keepaspectratio]{caso.png}
  \caption{Diagrama de Caso de Uso do \textit{Controle-se}.}
\end{figure}

\section{DER Conceitual}
\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth,height=.86\textheight,keepaspectratio]{DER.png}
  \caption{DER conceitual com relacionamento \textbf{N:N} entre Categoria e Gasto.}
\end{figure}

\section{Aderência aos Requisitos}
\begin{itemize}
  \item \textbf{Mínimo de 3 tabelas além de usuário}: \textit{Conta, Categoria, Gasto, Orçamento e receita}.
  \item \textbf{1:N}: Usuário–Conta; Conta–Gasto.
  \item \textbf{N:N}: \textbf{Categoria–Gasto} via \textit{GASTO\_CATEGORIA}.
  \item \textbf{Tipos}: data (\texttt{Gasto.data}); real (\texttt{Gasto.valor});
        string (vários); \textbf{string multivalorado} representado pela associação N:N (um gasto pode ter lista de categorias) e \textbf{atributo multivalorado nativo} \texttt{Gasto.observacoes} como array de strings.
\end{itemize}

\newpage
\part*{Fase II}
\addcontentsline{toc}{part}{Fase II}

\section{Estruturas de Dados Implementadas}

\subsection{Árvore B+ (Índices Primários)}

A \textbf{Árvore B+} foi implementada como estrutura de indexação primária para todas as tabelas do sistema.
É uma árvore de busca balanceada que mantém os dados ordenados e permite buscas, inserções e remoções eficientes.

\subsubsection*{Características da Implementação}
\begin{itemize}
  \item \textbf{Ordem}: 4 (número máximo de filhos por nó)
  \item \textbf{Número máximo de chaves}: 3 (ordem - 1)
  \item \textbf{Número mínimo de filhos} (nós internos não-raiz): 2 ($\lceil$4/2$\rceil$)
  \item \textbf{Número mínimo de chaves} (nós internos não-raiz): 1 ($\lceil$4/2$\rceil$ - 1)
  \item \textbf{Nós folha}: Armazenam todos os registros de dados e são encadeados para navegação sequencial
  \item \textbf{Nós internos}: Armazenam apenas chaves de roteamento e ponteiros para filhos
  \item \textbf{Balanceamento}: Automático através de divisão e fusão de nós
\end{itemize}

\subsubsection*{Aplicações no Sistema}
\begin{itemize}
  \item \texttt{tabelaUsuarios}: ID\_Usuario $\rightarrow$ Usuario
  \item \texttt{tabelaCategorias}: ID\_Categoria $\rightarrow$ Categoria
  \item \texttt{tabelaGastos}: ID\_Gasto $\rightarrow$ Gasto
  \item \texttt{tabelaReceitas}: ID\_Receita $\rightarrow$ Receita
  \item \texttt{tabelaContas}: ID\_Conta $\rightarrow$ Conta
  \item \texttt{tabelaOrcamentos}: ID\_Orcamento $\rightarrow$ Orcamento
  \item \texttt{tabelaTags}: ID\_Tag $\rightarrow$ Tag
\end{itemize}

\subsubsection*{Operações Implementadas}
\begin{itemize}
  \item \textbf{inserir(chave, dados)}: Inserção com balanceamento automático — O(log n)
  \item \textbf{buscar(chave)}: Busca por chave primária — O(log n)
  \item \textbf{remover(chave)}: Remoção lógica (lápide) — O(log n)
  \item \textbf{buscarIntervalo(inicio, fim)}: Busca por intervalo de chaves — O(log n + m)
  \item \textbf{listarTodos()}: Percurso sequencial nas folhas — O(n)
\end{itemize}

\subsection{Hash Extensível (Índices Secundários e Relacionamentos)}

O \textbf{Hash Extensível} foi implementado para gerenciar relacionamentos 1:N, N:N e índices secundários.
É uma estrutura de hash dinâmica que cresce conforme necessário, mantendo complexidade de busca O(1) médio.

\subsubsection*{Características da Implementação}
\begin{itemize}
  \item \textbf{Capacidade por bucket}: 3 registros
  \item \textbf{Profundidade global}: Número de bits usados para indexar o diretório
  \item \textbf{Profundidade local}: Número de bits usados por cada bucket
  \item \textbf{Crescimento dinâmico}: Diretório duplica quando bucket transborda e profundidades coincidem
\end{itemize}

\subsubsection*{Aplicações no Sistema}

\textbf{Relacionamentos 1:N (Foreign Keys):}
\begin{itemize}
  \item \texttt{indiceUsuarioCategorias}: Usuario $\rightarrow$ Lista<Categoria>
  \item \texttt{indiceUsuarioGastos}: Usuario $\rightarrow$ Lista<Gasto>
  \item \texttt{indiceUsuarioReceitas}: Usuario $\rightarrow$ Lista<Receita>
  \item \texttt{indiceUsuarioContas}: Usuario $\rightarrow$ Lista<Conta>
  \item \texttt{indiceUsuarioOrcamentos}: Usuario $\rightarrow$ Lista<Orcamento>
  \item \texttt{indiceUsuarioTags}: Usuario $\rightarrow$ Lista<Tag>
  \item \texttt{indiceCategoriaOrcamentos}: Categoria $\rightarrow$ Lista<Orcamento>
\end{itemize}

\textbf{Relacionamento N:N:}
\begin{itemize}
  \item \texttt{indiceCategoriaGastos}: Categoria $\rightarrow$ Lista<Gasto>
  \item \texttt{indiceGastoCategorias}: Gasto $\rightarrow$ Lista<Categoria>
  \item \texttt{indiceTagGastos}: Tag $\rightarrow$ Lista<Gasto>
  \item \texttt{indiceGastoTags}: Gasto $\rightarrow$ Lista<Tag>
  \item \texttt{indiceTagReceitas}: Tag $\rightarrow$ Lista<Receita>
  \item \texttt{indiceReceitaTags}: Receita $\rightarrow$ Lista<Tag>
\end{itemize}

\textbf{Índices para Consultas Específicas:}
\begin{itemize}
  \item \texttt{indiceEmailUsuarios}: Hash(Email) $\rightarrow$ Usuario (para login)
  \item \texttt{indiceDataGastos}: Hash(Data) $\rightarrow$ Lista<Gasto> (filtro por data)
  \item \texttt{indiceDataReceitas}: Hash(Data) $\rightarrow$ Lista<Receita> (filtro por data)
  \item \texttt{indiceTipoContas}: Hash(Tipo) $\rightarrow$ Lista<Conta> (filtro por tipo)
\end{itemize}

\subsubsection*{Operações Implementadas}
\begin{itemize}
  \item \textbf{inserir(chave, valor)}: Inserção com divisão de bucket se necessário — O(1) médio
  \item \textbf{buscar(chave)}: Retorna lista de valores associados — O(1) médio
  \item \textbf{remover(chave)}: Remove todas entradas com a chave — O(1) médio
  \item \textbf{expandirDiretorio()}: Duplica diretório quando necessário — O(2^d) onde d = profundidade
\end{itemize}

\section{Análise de Complexidade}

\begin{table}[H]
\centering
\small
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Operação} & \textbf{Estrutura} & \textbf{Complexidade} & \textbf{Caso} \\
\hline
Busca por ID (chave primária) & Árvore B+ & O(log n) & Pior caso \\
Inserção com nova chave & Árvore B+ & O(log n) & Pior caso \\
Remoção lógica (lápide) & Árvore B+ & O(log n) & Pior caso \\
Busca por intervalo & Árvore B+ & O(log n + m) & m = registros retornados \\
Listagem completa & Árvore B+ & O(n) & Percurso sequencial \\
\hline
Busca por FK ou atributo & Hash Extensível & O(1) & Caso médio \\
Inserção em índice secundário & Hash Extensível & O(1) & Caso médio \\
Remoção de índice secundário & Hash Extensível & O(1) & Caso médio \\
Filtro por categoria & Hash Extensível & O(1 + k) & k = registros da categoria \\
Filtro por data & Hash Extensível & O(1 + k) & k = registros da data \\
Login (busca por email) & Hash Extensível & O(1) & Caso médio \\
\hline
\end{tabular}
\caption{Complexidade temporal das operações implementadas.}
\end{table}

\section{Persistência em Disco}

O sistema implementa persistência de dados utilizando \textbf{serialização Java} para salvar e carregar
as estruturas de dados em arquivos binários \texttt{.db}.

\subsection*{Arquivos de Persistência}
\begin{itemize}
  \item \texttt{usuarios.db}: Tabela de usuários
  \item \texttt{categorias.db}: Tabela de categorias
  \item \texttt{gastos.db}: Tabela de gastos
  \item \texttt{receitas.db}: Tabela de receitas
  \item \texttt{contas.db}: Tabela de contas bancárias
  \item \texttt{orcamentos.db}: Tabela de orçamentos
  \item \texttt{tags.db}: Tabela de tags
  \item \texttt{contadores.db}: Contadores de IDs auto-incrementais
  \item \texttt{categoria\_gasto.db}: Relacionamento N:N entre Categoria e Gasto
  \item \texttt{transacao\_tag.db}: Relacionamento N:N entre Transações (Gastos/Receitas) e Tags
\end{itemize}

\subsection*{Estratégia de Persistência}
\begin{itemize}
  \item \textbf{Salvamento}: Após cada operação de escrita (inserção, atualização, remoção)
  \item \textbf{Carregamento}: Automático na inicialização do servidor
  \item \textbf{Formato}: Serialização Java (ObjectOutputStream/ObjectInputStream)
  \item \textbf{Exclusão lógica}: Registros marcados como \texttt{ativo = false} (lápide)
  \item \textbf{Verificação de Índices}: O sistema realiza verificação completa de integridade dos índices na inicialização, checando todos os índices primários (B+ Tree) e secundários essenciais (Hash Extensível). Se algum índice primário estiver ausente, o sistema automaticamente reconstrói todos os índices a partir dos dados persistidos, garantindo consistência e recuperação automática de possíveis corrupções.
\end{itemize}

\section{Operações CRUD Implementadas}

\subsection{Usuários}
\begin{itemize}
  \item \textbf{Create}: \texttt{cadastrarUsuario(nome, email, senha)} — verifica unicidade de email
  \item \textbf{Read}: \texttt{buscarUsuario(id)}, \texttt{buscarUsuarioPorEmail(email)}
  \item \textbf{Update}: \texttt{atualizarUsuario(id, novaSenha)}
  \item \textbf{Delete}: Exclusão lógica com \texttt{ativo = false}
  \item \textbf{Auth}: \texttt{autenticarUsuario(email, senha)}
\end{itemize}

\subsection{Categorias}
\begin{itemize}
  \item \textbf{Create}: \texttt{cadastrarCategoria(nome, idUsuario)}
  \item \textbf{Read}: \texttt{buscarCategoria(id)}, \texttt{listarCategoriasPorUsuario(idUsuario)}
  \item \textbf{Update}: \texttt{atualizarCategoria(id, novoNome)}
  \item \textbf{Delete}: \texttt{removerCategoria(id)} — exclusão lógica
\end{itemize}

\subsection{Gastos e Receitas}
\begin{itemize}
  \item \textbf{Create}: \texttt{registrarGasto(...)}, \texttt{registrarReceita(...)}
  \item \textbf{Read}: Busca por ID, por usuário, por categoria, por data
  \item \textbf{Update}: \texttt{atualizarGasto(...)}, \texttt{atualizarReceita(...)}
  \item \textbf{Delete}: Exclusão lógica
  \item \textbf{Filtros}: Combinação de categoria + data usando índices Hash
\end{itemize}

\subsection{Contas Bancárias}
\begin{itemize}
  \item \textbf{Create}: \texttt{cadastrarConta(nome, tipo, saldoInicial, idUsuario)}
  \item \textbf{Read}: \texttt{buscarConta(id)}, \texttt{listarContasPorUsuario(idUsuario)}
  \item \textbf{Update}: \texttt{atualizarConta(id, novoNome, novoSaldo)}
  \item \textbf{Delete}: Exclusão lógica
\end{itemize}

\subsection{Orçamentos}
\begin{itemize}
  \item \textbf{Create}: \texttt{cadastrarOrcamento(valorPlanejado, periodo, idCategoria, idUsuario)}
  \item \textbf{Read}: \texttt{buscarOrcamento(id)}, \texttt{listarOrcamentosPorUsuario(idUsuario)}
  \item \textbf{Update}: \texttt{atualizarOrcamento(id, novoValor)}
  \item \textbf{Delete}: Exclusão lógica
\end{itemize}

\subsection{Tags (Sistema de Etiquetas)}
\begin{itemize}
  \item \textbf{Create}: \texttt{cadastrarTag(nome, cor, idUsuario)} — cria tag personalizada com cor em hexadecimal
  \item \textbf{Read}: \texttt{buscarTag(id)}, \texttt{listarTagsPorUsuario(idUsuario)}
  \item \textbf{Update}: \texttt{atualizarTag(id, novoNome, novaCor)}
  \item \textbf{Delete}: Exclusão lógica
  \item \textbf{Associação}: \texttt{associarTagTransacao(idTransacao, tipoTransacao, idTag)}
  \item \textbf{Consultas}: \texttt{buscarTagsGasto(idGasto)}, \texttt{buscarTagsReceita(idReceita)}
  \item \textbf{Filtros}: \texttt{buscarGastosPorTag(idTag)}, \texttt{buscarReceitasPorTag(idTag)}
\end{itemize}

\noindent \textbf{Características das Tags:}
\begin{itemize}
  \item Sistema de etiquetas personalizáveis para organização de transações
  \item Cada tag possui nome único, cor em formato hexadecimal (ex: \texttt{\#3498db})
  \item Relacionamento N:N com Gastos e Receitas (uma transação pode ter múltiplas tags)
  \item Filtro de transações por tags no frontend para análise rápida
  \item Interface visual com badges coloridos para identificação imediata
\end{itemize}

\section{Arquitetura do Sistema}

O sistema implementa uma arquitetura de três camadas:

\subsection*{Camada 1: Frontend Web}
\begin{itemize}
  \item \textbf{Tecnologia}: HTML5 + CSS3 + JavaScript (ES6+)
  \item \textbf{Responsabilidades}: Interface do usuário, validação de formulários, comunicação com API REST
  \item \textbf{Arquivos}: \texttt{index.html}, \texttt{styles.css}, \texttt{app.js}
\end{itemize}

\subsection*{Camada 2: API REST (Servidor Java)}
\begin{itemize}
  \item \textbf{Tecnologia}: Java 11+ com \texttt{com.sun.net.httpserver.HttpServer}
  \item \textbf{Responsabilidades}: Roteamento de requisições, validação de dados, lógica de negócios
  \item \textbf{Endpoints}: Autenticação, Categorias, Contas, Gastos, Receitas, Orçamentos, Tags, Dashboard
  \item \textbf{Formato}: JSON para entrada e saída
  \item \textbf{Arquivo principal}: \texttt{ControleSeServer.java}
\end{itemize}

\noindent \textbf{Principais Endpoints Implementados:}
\begin{itemize}
  \item \texttt{POST /api/auth/login} — Autenticação de usuário
  \item \texttt{POST /api/categories} — Criar categoria
  \item \texttt{GET /api/categories?userId=X} — Listar categorias do usuário
  \item \texttt{POST /api/expenses} — Registrar gasto (com tags opcionais)
  \item \texttt{POST /api/incomes} — Registrar receita (com tags opcionais)
  \item \texttt{GET /api/transactions?userId=X} — Listar transações (inclui tags)
  \item \texttt{POST /api/tags} — Criar tag personalizada
  \item \texttt{GET /api/tags?userId=X} — Listar tags do usuário
  \item \texttt{PUT /api/tags/\{id\}} — Atualizar tag
  \item \texttt{DELETE /api/tags/\{id\}} — Excluir tag (lógica)
\end{itemize}

\subsection*{Camada 3: Banco de Dados (Estruturas de Dados)}
\begin{itemize}
  \item \textbf{Tecnologia}: Árvore B+ e Hash Extensível implementados manualmente
  \item \textbf{Responsabilidades}: Armazenamento, indexação, busca eficiente, persistência
  \item \textbf{Arquivos}: \texttt{BancoDados.java}, \texttt{ArvoreBPlus.java}, \texttt{HashExtensivel.java}
\end{itemize}

\section{Atributos Multivalorados}

\subsection{Implementação}

\textbf{Atributo Multivalorado Nativo:}
\begin{itemize}
  \item \textbf{Campo}: \texttt{Gasto.observacoes} como \texttt{String[]}
  \item \textbf{Tipo}: Array de strings para múltiplas observações por gasto
  \item \textbf{Persistência}: Via Java Serialization junto com o objeto \texttt{Gasto}
  \item \textbf{Operações}: Adição dinâmica de observações via método \texttt{adicionarObservacao()}
\end{itemize}

\textbf{Relacionamentos N:N (Simulando Multivalorados):}
\begin{itemize}
  \item \textbf{Categoria-Gasto}: Via tabela \texttt{CategoriaGasto}
  \item \textbf{Tag-Transação}: Via tabela \texttt{TransacaoTag}
  \item \textbf{Índices}: Hash Extensível para busca eficiente
  \item \textbf{Integridade}: Chaves estrangeiras para consistência
\end{itemize}

\subsection{Características Técnicas}

\begin{itemize}
  \item \textbf{Serialização}: Arrays nativos preservados na persistência
  \item \textbf{Performance}: Acesso direto sem joins para observações
  \item \textbf{Flexibilidade}: Tamanho dinâmico do array de observações
  \item \textbf{UI}: Campo textarea com separação por vírgula/quebra de linha
\end{itemize}

\section{Testes e Validação}

\subsection*{Cenários Testados}
\begin{itemize}
  \item Cadastro de usuário com email único (validação de duplicação)
  \item Login com credenciais válidas e inválidas
  \item Operações CRUD completas em todas as entidades
  \item Filtros combinados: categoria + data + tags para gastos e receitas
  \item Persistência: reinicialização do servidor mantém dados
  \item Exclusão lógica: registros removidos não aparecem mas permanecem no arquivo
  \item Crescimento dinâmico do Hash Extensível com múltiplas inserções
  \item Balanceamento da Árvore B+ com inserções e remoções
  \item Associação N:N de tags com múltiplas transações
  \item Criação de categoria inline durante cadastro de gasto
  \item Filtro de transações por tags com busca client-side
  \item Atributo multivalorado: múltiplas observações por gasto
  \item Persistência de arrays de strings via serialização
\end{itemize}

\subsection*{Validações Implementadas}
\begin{itemize}
  \item Email único para usuários
  \item IDs auto-incrementais para todas as entidades
  \item Verificação de existência antes de operações de atualização/remoção
  \item Tratamento de exceções em operações de I/O
  \item Validação de relacionamentos (FK válidas)
\end{itemize}

\section{Sistema de Relatórios}

\subsection{Implementação}

O sistema de relatórios foi implementado como uma funcionalidade completa que permite análise detalhada dos dados financeiros do usuário através de dashboards interativos e exportação de dados.

\subsubsection*{Backend (Java)}
\begin{itemize}
  \item \textbf{ReportsHandler}: Novo handler para processar requisições de relatórios
  \item \textbf{Métodos de busca por período}: \texttt{buscarGastosPorPeriodo()} e \texttt{buscarReceitasPorPeriodo()}
  \item \textbf{Exportação de dados}: Métodos para exportar relatórios em CSV e XLSX
  \item \textbf{Análise de dados}: Cálculos de totais, análise por categoria, conta e evolução mensal
\end{itemize}

\subsubsection*{Frontend (JavaScript + Chart.js)}
\begin{itemize}
  \item \textbf{Dashboards interativos}: 4 tipos de visualizações gráficas
  \item \textbf{Controles de período}: Mensal, anual e período personalizado
  \item \textbf{Exportação}: Botões para exportar em CSV ou XLSX
  \item \textbf{Cards de resumo}: Totais de receitas, gastos e saldo do período
\end{itemize}

\subsection{Tipos de Relatórios}

\subsubsection*{Visualizações Implementadas}
\begin{enumerate}
  \item \textbf{Gráfico de Pizza}: Gastos por categoria com percentuais
  \item \textbf{Gráfico de Linha}: Evolução mensal de receitas vs gastos (últimos 12 meses)
  \item \textbf{Gráfico de Barras}: Gastos por conta bancária
  \item \textbf{Lista}: Top 5 maiores gastos do período
\end{enumerate}

\subsubsection*{Períodos Disponíveis}
\begin{itemize}
  \item \textbf{Mensal}: Dados do mês atual
  \item \textbf{Anual}: Dados do ano atual
  \item \textbf{Personalizado}: Usuário define início e fim
\end{itemize}

\subsection{Exportação de Dados}

\subsubsection*{Formatos Suportados}
\begin{itemize}
  \item \textbf{CSV}: Formato de planilha simples, compatível com Excel
  \item \textbf{XLSX}: Formato Excel nativo (simulado com separadores de tabulação)
\end{itemize}

\subsubsection*{Dados Exportados}
\begin{itemize}
  \item Tipo de transação (Gasto/Receita)
  \item Descrição da transação
  \item Valor monetário
  \item Data da transação
  \item Categoria(ies) associada(s)
  \item Conta bancária utilizada
  \item Observações (quando existirem)
\end{itemize}

\subsection{Análise de Dados}

O sistema realiza análises automáticas dos dados financeiros:

\begin{itemize}
  \item \textbf{Totais por período}: Soma de receitas, gastos e saldo
  \item \textbf{Análise por categoria}: Distribuição percentual dos gastos
  \item \textbf{Análise por conta}: Gastos por conta bancária
  \item \textbf{Evolução temporal}: Tendências mensais dos últimos 12 meses
  \item \textbf{Top gastos}: Maiores despesas do período para identificação de padrões
\end{itemize}

\section{Repositório do Projeto}

O código-fonte completo do projeto está disponível publicamente no GitHub:

\begin{center}
\url{https://github.com/marcoslaine/controle-se}
\end{center}

\noindent O repositório contém:
\begin{itemize}
  \item Código-fonte Java completo (estruturas de dados, servidor, banco de dados)
  \item Interface web (HTML, CSS, JavaScript)
  \item Documentação técnica e diagramas
  \item Instruções de compilação e execução
  \item Exemplos de uso e testes
  \item Sistema completo de relatórios com dashboards e exportação
\end{itemize}

\section*{Questionário Técnico - Fase II}

\textbf{a) Qual a estrutura usada para representar os registros?}

Os registros são armazenados em disco usando a seguinte estrutura:

\begin{itemize}
  \item \textbf{Formato}: Arquivos binários \texttt{.db} usando serialização Java nativa
  \item \textbf{Organização}: Um arquivo por entidade (usuarios.db, gastos.db, categorias.db, etc.)
  \item \textbf{Estrutura interna}: Cada arquivo contém uma lista serializada de objetos Java
  \item \textbf{Classes}: Implementam interface \texttt{Serializable} com campos específicos:
    \begin{itemize}
      \item \texttt{Usuario}: id, nome, email, senha, ativo
      \item \texttt{Gasto}: id, idUsuario, valor, descricao, data, observacoes[], ativo
      \item \texttt{Categoria}: id, idUsuario, nome, cor, ativo
      \item \texttt{Tag}: id, idUsuario, nome, cor, ativo
    \end{itemize}
  \item \textbf{Persistência}: Carregamento completo do arquivo na memória, modificação e reescrita
  \item \textbf{Índices}: Mantidos em arquivos separados para busca eficiente (Hash Extensível e B+ Tree)
\end{itemize}

\textbf{b) Como atributos multivalorados do tipo string foram tratados?}

Atributos multivalorados do tipo string foram implementados de duas formas:
\begin{itemize}
  \item \textbf{Nativo}: Campo \texttt{observacoes} na classe \texttt{Gasto} como \texttt{String[]}
  \item \textbf{Simulado via relacionamento N:N}: Categorias de um gasto e tags de uma transação através de tabelas de relacionamento (\texttt{CategoriaGasto} e \texttt{TransacaoTag})
\end{itemize}

\textbf{c) Como foi implementada a exclusão lógica?}

A exclusão lógica foi implementada através do campo booleano \texttt{ativo} presente em todas as entidades. Quando um registro é "excluído", o campo \texttt{ativo} é definido como \texttt{false}, mas o registro permanece no banco de dados. As consultas filtram apenas registros com \texttt{ativo = true}.

\textbf{d) Além das PKs, quais outras chaves foram utilizadas nesta etapa?}

Além das chaves primárias (IDs), foram utilizadas:
\begin{itemize}
  \item \textbf{Chaves estrangeiras}: \texttt{idUsuario} em todas as entidades principais
  \item \textbf{Chaves de relacionamento}: \texttt{idCategoria}, \texttt{idGasto}, \texttt{idTag}, \texttt{idTransacao}
  \item \textbf{Chaves de busca}: \texttt{email} (usuários), \texttt{nome} (categorias, contas, tags)
\end{itemize}

\textbf{e) Quais tipos de estruturas foram utilizadas para cada chave de pesquisa?}

\begin{itemize}
  \item \textbf{Árvore B+ (ordem 4)}: Todas as chaves primárias (IDs) e chaves de busca principais
  \item \textbf{Hash Extensível (3 registros/bucket)}: Relacionamentos 1:N e N:N, índices secundários
  \item \textbf{Índices primários}: Usuários, Categorias, Gastos, Receitas, Contas, Orçamentos, Tags
  \item \textbf{Índices secundários}: Relacionamentos categoria-gasto, tag-transação, usuário-entidades
\end{itemize}

\textbf{f) Como foi implementado o relacionamento 1:N?}

Os relacionamentos 1:N foram implementados através de:
\begin{itemize}
  \item \textbf{Chave estrangeira}: Campo \texttt{idUsuario} em todas as entidades dependentes
  \item \textbf{Navegação}: Busca por \texttt{idUsuario} para recuperar registros relacionados
  \item \textbf{Integridade referencial}: Validação de existência do usuário antes de inserir registros dependentes
  \item \textbf{Exclusão em cascata}: Ao excluir usuário, todos os registros dependentes são marcados como inativos
\end{itemize}

\textbf{g) Como os índices são persistidos em disco?}

\begin{itemize}
  \item \textbf{Formato}: Serialização Java nativa (\texttt{.db} files)
  \item \textbf{Atualização}: Índices são atualizados imediatamente após cada operação de escrita
  \item \textbf{Sincronização}: Salvamento automático após cada modificação (insert, update, delete)
  \item \textbf{Estrutura}: Cada índice é um arquivo separado (ex: \texttt{idx\_usuarios.db}, \texttt{idx\_categorias.db})
  \item \textbf{Verificação de Integridade}: O sistema verifica a existência de todos os índices primários (7 arquivos) e índices secundários essenciais (6 arquivos) antes do carregamento. Se algum índice primário estiver faltando, o sistema força a reconstrução completa dos índices a partir dos dados persistidos, garantindo consistência.
  \item \textbf{Carregamento Inteligente}: Na inicialização, o sistema verifica se os arquivos de índice existem. Se existirem, carrega os índices diretamente dos arquivos. Caso contrário, reconstrói os índices a partir dos dados e os salva para uso futuro.
\end{itemize}

\textbf{h) Como está estruturado o projeto no GitHub?}

\begin{itemize}
  \item \textbf{src/}: Código-fonte Java (classes principais, handlers, utilitários)
  \item \textbf{data/}: Arquivos de banco de dados (\texttt{.db})
  \item \textbf{docs/}: Documentação técnica (LaTeX, diagramas)
  \item \textbf{Raiz}: Arquivos frontend (\texttt{index.html}, \texttt{styles.css}, \texttt{app.js})
  \item \textbf{Arquitetura}: Frontend Web + Backend Java + Banco de Dados Customizado
  \item \textbf{Módulos}: Separação clara entre lógica de negócio, persistência e interface
\end{itemize}

\newpage
\part*{Fase III}
\addcontentsline{toc}{part}{Fase III}

\section{Relacionamentos N:N}

\subsection{Implementação dos Relacionamentos Muitos-para-Muitos}

O sistema implementa dois relacionamentos N:N principais através de tabelas de junção, permitindo que múltiplas entidades se relacionem de forma flexível e eficiente.

\subsubsection*{Categoria ↔ Gasto (N:N)}
\begin{itemize}
  \item \textbf{Tabela de Junção}: \texttt{CategoriaGasto}
  \item \textbf{Chaves}: \texttt{idCategoriaGasto} (PK), \texttt{idCategoria} (FK), \texttt{idGasto} (FK)
  \item \textbf{Propósito}: Permitir que um gasto tenha múltiplas categorias e uma categoria possa estar associada a múltiplos gastos
  \item \textbf{Implementação}: Hash Extensível para indexação bidirecional eficiente
  \item \textbf{Índices}: 
    \begin{itemize}
      \item \texttt{indiceCategoriaGastos}: Categoria → Lista<CategoriaGasto>
      \item \texttt{indiceGastoCategorias}: Gasto → Lista<CategoriaGasto>
    \end{itemize}
\end{itemize}

\subsubsection*{Tag ↔ Transação (N:N)}
\begin{itemize}
  \item \textbf{Tabela de Junção}: \texttt{TransacaoTag}
  \item \textbf{Chaves}: \texttt{idTransacaoTag} (PK), \texttt{idTransacao} (FK), \texttt{tipoTransacao} ("GASTO" ou "RECEITA"), \texttt{idTag} (FK)
  \item \textbf{Propósito}: Sistema de tags personalizáveis que permite múltiplas tags por transação (gasto ou receita)
  \item \textbf{Implementação}: Hash Extensível para indexação bidirecional eficiente
  \item \textbf{Índices}:
    \begin{itemize}
      \item \texttt{indiceTagGastos}: Tag → Lista<Gasto>
      \item \texttt{indiceGastoTags}: Gasto → Lista<Tag>
      \item \texttt{indiceTagReceitas}: Tag → Lista<Receita>
      \item \texttt{indiceReceitaTags}: Receita → Lista<Tag>
    \end{itemize}
\end{itemize}

\subsection{Estruturas de Dados para N:N}

\subsubsection*{Hash Extensível para Relacionamentos}
\begin{itemize}
  \item \textbf{Capacidade por bucket}: 3 registros
  \item \textbf{Chave de indexação}: ID da entidade (categoria, gasto, tag ou transação)
  \item \textbf{Valor armazenado}: Objeto de relacionamento (\texttt{CategoriaGasto} ou \texttt{TransacaoTag}) ou ID da entidade relacionada
  \item \textbf{Operações}: Inserção, busca e remoção de relacionamentos
  \item \textbf{Complexidade}: O(1) médio para operações de relacionamento
  \item \textbf{Crescimento dinâmico}: Diretório duplica automaticamente quando necessário
\end{itemize}

\subsection{Operações Implementadas}

\subsubsection*{Relacionamento Categoria-Gasto}

\textbf{Inserção de Relacionamento:}
\begin{itemize}
  \item \texttt{adicionarCategoriaAoGasto(idCategoria, idGasto)}: Cria novo relacionamento N:N
  \item \texttt{adicionarCategoriaAoGastoSemSalvar()}: Versão otimizada sem persistência imediata
  \item Validação automática da existência das entidades antes de criar relacionamento
  \item Atualização automática dos índices bidirecionais
\end{itemize}

\textbf{Busca de Relacionamentos:}
\begin{itemize}
  \item \texttt{buscarGastosPorCategoria(idCategoria)}: Retorna todos os gastos de uma categoria — O(1) médio + O(k) onde k = número de gastos
  \item \texttt{buscarCategoriasDoGasto(idGasto)}: Retorna todas as categorias de um gasto — O(1) médio + O(k) onde k = número de categorias
  \item \texttt{gastoTemCategoria(idGasto, idCategoria)}: Verifica se um gasto possui uma categoria específica — O(1) médio
\end{itemize}

\textbf{Remoção de Relacionamento:}
\begin{itemize}
  \item \texttt{removerCategoriaDoGasto(idCategoria, idGasto)}: Exclusão lógica do relacionamento
  \item Campo \texttt{ativo = false} mantém histórico dos dados
  \item Persistência automática após remoção
\end{itemize}

\subsubsection*{Relacionamento Tag-Transação}

\textbf{Inserção de Relacionamento:}
\begin{itemize}
  \item \texttt{associarTagTransacao(idTransacao, tipoTransacao, idTag)}: Associa tag a gasto ou receita
  \item Suporte para tipos "GASTO" e "RECEITA"
  \item Atualização automática dos índices específicos por tipo
\end{itemize}

\textbf{Busca de Relacionamentos:}
\begin{itemize}
  \item \texttt{buscarTagsGasto(idGasto)}: Retorna todas as tags de um gasto — O(1) médio + O(k)
  \item \texttt{buscarTagsReceita(idReceita)}: Retorna todas as tags de uma receita — O(1) médio + O(k)
  \item \texttt{buscarGastosPorTag(idTag)}: Retorna todos os gastos com uma tag específica — O(1) médio + O(k)
  \item \texttt{buscarReceitasPorTag(idTag)}: Retorna todas as receitas com uma tag específica — O(1) médio + O(k)
\end{itemize}

\subsection{Persistência dos Relacionamentos N:N}

\subsubsection*{Arquivos de Persistência}
\begin{itemize}
  \item \texttt{data/categoria\_gasto.db}: Armazena todos os relacionamentos Categoria-Gasto
  \item \texttt{data/transacao\_tag.db}: Armazena todos os relacionamentos Tag-Transação
  \item \textbf{Formato}: Serialização Java nativa (\texttt{ObjectOutputStream})
  \item \textbf{Estrutura}: Lista de objetos \texttt{CategoriaGasto} ou \texttt{TransacaoTag}
\end{itemize}

\subsubsection*{Estratégia de Persistência}
\begin{itemize}
  \item \textbf{Salvamento}: Após cada operação de escrita (inserção, remoção)
  \item \textbf{Carregamento}: Automático na inicialização do servidor
  \item \textbf{Verificação de Índices}: O sistema verifica a integridade dos índices Hash Extensível antes do carregamento. Se os índices existirem, são carregados diretamente. Caso contrário, são reconstruídos a partir dos relacionamentos persistidos.
  \item \textbf{Reconstrução de índices}: Os índices Hash Extensível são reconstruídos a partir dos relacionamentos carregados quando necessário, garantindo sincronização entre dados e índices.
  \item \textbf{Exclusão lógica}: Relacionamentos marcados como \texttt{ativo = false} são mantidos no arquivo mas não aparecem nas consultas
\end{itemize}

\subsection{Operações de Navegação}

\subsubsection*{Navegação Bidirecional}
O sistema permite navegação eficiente em ambas as direções dos relacionamentos N:N:

\begin{itemize}
  \item \textbf{Categoria → Gastos}: Dada uma categoria, encontrar todos os gastos associados
  \item \textbf{Gasto → Categorias}: Dado um gasto, encontrar todas as categorias associadas
  \item \textbf{Tag → Transações}: Dada uma tag, encontrar todas as transações (gastos e receitas) associadas
  \item \textbf{Transação → Tags}: Dada uma transação, encontrar todas as tags associadas
\end{itemize}

\subsubsection*{Filtros Combinados}
O sistema suporta filtros combinados que utilizam os relacionamentos N:N:

\begin{itemize}
  \item \texttt{buscarGastosComFiltros(idUsuario, idCategoria, data)}: Combina filtro por categoria (via N:N) com filtro por data
  \item Validação de relacionamento através do método \texttt{gastoTemCategoria()}
  \item Complexidade: O(n) onde n = número de gastos do usuário, com verificação O(1) por gasto
\end{itemize}

\subsection{Integridade Referencial}

\subsubsection*{Validações Implementadas}
\begin{itemize}
  \item \textbf{Validação de existência}: Verificação de existência das entidades antes de criar relacionamentos
  \item \textbf{Validação de estado}: Apenas entidades ativas (\texttt{ativo = true}) podem ser relacionadas
  \item \textbf{Prevenção de duplicatas}: Sistema permite múltiplas categorias/tags por gasto, mas evita relacionamentos duplicados
\end{itemize}

\subsubsection*{Exclusão em Cascata}
\begin{itemize}
  \item \textbf{Exclusão de entidade}: Quando uma categoria, gasto ou tag é excluída (lógica), os relacionamentos permanecem mas não aparecem nas consultas
  \item \textbf{Manutenção de histórico}: Relacionamentos antigos são preservados para análise histórica
  \item \textbf{Consistência}: Os índices são atualizados automaticamente para refletir exclusões lógicas
\end{itemize}

\subsection{Interface de Usuário para N:N}

\subsubsection*{Seleção Múltipla de Categorias}
\begin{itemize}
  \item \textbf{Checkboxes}: Interface web com checkboxes para seleção de múltiplas categorias em gastos
  \item \textbf{Validação}: Pelo menos uma categoria deve ser selecionada ao criar um gasto
  \item \textbf{Persistência}: Salvamento automático dos relacionamentos criados via API REST
  \item \textbf{Exibição}: Gastos exibem todas as categorias associadas na interface
\end{itemize}

\subsubsection*{Sistema de Tags}
\begin{itemize}
  \item \textbf{Criação e associação}: Tags podem ser criadas e associadas a transações via interface web
  \item \textbf{Associação múltipla}: Uma transação pode ter múltiplas tags simultaneamente
  \item \textbf{Filtros visuais}: Interface permite filtrar transações por tags específicas
  \item \textbf{Badges coloridos}: Tags são exibidas como badges coloridos para identificação visual rápida
  \item \textbf{Gerenciamento}: CRUD completo de tags com interface dedicada
\end{itemize}

\subsection{Análise de Complexidade}

\begin{table}[H]
\centering
\small
\begin{tabular}{|l|c|c|}
\hline
\textbf{Operação} & \textbf{Estrutura} & \textbf{Complexidade} \\
\hline
Adicionar relacionamento Categoria-Gasto & Hash Extensível & O(1) médio \\
Buscar gastos por categoria & Hash Extensível & O(1) médio + O(k) \\
Buscar categorias de um gasto & Hash Extensível & O(1) médio + O(k) \\
Remover relacionamento & Hash Extensível & O(1) médio + O(k) \\
Associar tag a transação & Hash Extensível & O(1) médio \\
Buscar tags de uma transação & Hash Extensível & O(1) médio + O(k) \\
Filtro combinado (categoria + data) & Hash + Árvore B+ & O(n) onde n = gastos do usuário \\
\hline
\end{tabular}
\caption{Complexidade temporal das operações de relacionamento N:N. k = número de registros retornados.}
\end{table}

\subsection{Benefícios dos Relacionamentos N:N}

\begin{itemize}
  \item \textbf{Flexibilidade}: Categorização múltipla permite análise mais detalhada e precisa dos gastos
  \item \textbf{Organização}: Sistema de tags oferece categorização personalizada além das categorias tradicionais
  \item \textbf{Escalabilidade}: Estruturas Hash Extensível suportam grandes volumes de dados com complexidade O(1) médio
  \item \textbf{Usabilidade}: Interface intuitiva para gerenciamento de relacionamentos múltiplos
  \item \textbf{Performance}: Busca eficiente através de índices bidirecionais
  \item \textbf{Integridade}: Validações automáticas garantem consistência dos dados
\end{itemize}

\subsection{Exemplos de Uso}

\subsubsection*{Criação de Gasto com Múltiplas Categorias}
Ao registrar um gasto, o sistema permite associar múltiplas categorias. Por exemplo, um gasto de "Supermercado" pode ser categorizado como "Alimentação" e "Casa" simultaneamente, permitindo análises mais flexíveis.

\subsubsection*{Sistema de Tags para Organização}
Tags permitem organização adicional além das categorias. Por exemplo, uma receita pode ter tags como "Salário", "Freelance" e "Urgente", facilitando filtros e análises personalizadas.

\subsubsection*{Filtros Avançados}
O sistema permite combinar filtros por categoria (via relacionamento N:N) com outros critérios como data, permitindo consultas complexas de forma eficiente.

\section*{Questionário Técnico - Fase III}

\textbf{1. Qual foi o relacionamento N:N escolhido e quais tabelas ele conecta?}

O sistema implementa dois relacionamentos N:N principais:

\begin{itemize}
  \item \textbf{Categoria ↔ Gasto (N:N)}: Conecta as tabelas \texttt{Categoria} e \texttt{Gasto} através da tabela intermediária \texttt{CategoriaGasto}. Este relacionamento permite que um gasto tenha múltiplas categorias e que uma categoria possa estar associada a múltiplos gastos.
  \item \textbf{Tag ↔ Transação (N:N)}: Conecta as tabelas \texttt{Tag} e \texttt{Transação} (que pode ser \texttt{Gasto} ou \texttt{Receita}) através da tabela intermediária \texttt{TransacaoTag}. Este relacionamento permite que uma transação tenha múltiplas tags e que uma tag possa estar associada a múltiplas transações.
\end{itemize}

O relacionamento principal escolhido para a Fase III é o \textbf{Categoria ↔ Gasto}, que é o relacionamento N:N fundamental do sistema, permitindo categorização múltipla e flexível dos gastos.

\textbf{2. Qual estrutura de índice foi utilizada (B+ ou Hash Extensível)? Justifique a escolha.}

Foi utilizada a estrutura \textbf{Hash Extensível} para indexar os relacionamentos N:N. A justificativa para esta escolha é:

\begin{itemize}
  \item \textbf{Complexidade de busca}: Hash Extensível oferece O(1) médio para busca, inserção e remoção, enquanto Árvore B+ oferece O(log n). Para relacionamentos N:N, onde as buscas são frequentes e não requerem ordenação, o Hash Extensível é mais eficiente.
  \item \textbf{Natureza das consultas}: As consultas em relacionamentos N:N são tipicamente por igualdade (buscar todos os gastos de uma categoria, buscar todas as categorias de um gasto), não por intervalo ou ordenação, o que favorece o uso de hash.
  \item \textbf{Navegação bidirecional}: O Hash Extensível permite criar índices bidirecionais eficientes (categoria → gastos e gasto → categorias) sem duplicação excessiva de dados.
  \item \textbf{Crescimento dinâmico}: O Hash Extensível cresce dinamicamente conforme necessário, adaptando-se ao volume de relacionamentos sem necessidade de rebalanceamento complexo.
  \item \textbf{Performance em operações frequentes}: Como os relacionamentos N:N são consultados frequentemente durante filtros e navegação, o O(1) médio do Hash Extensível oferece melhor performance prática.
\end{itemize}

\textbf{3. Como foi implementada a chave composta da tabela intermediária?}

A chave composta da tabela intermediária \texttt{CategoriaGasto} foi implementada da seguinte forma:

\begin{itemize}
  \item \textbf{Chave primária}: \texttt{idCategoriaGasto} (PK) — ID auto-incremental único para cada relacionamento
  \item \textbf{Chaves estrangeiras}: 
    \begin{itemize}
      \item \texttt{idCategoria} (FK) — Referência à tabela \texttt{Categoria}
      \item \texttt{idGasto} (FK) — Referência à tabela \texttt{Gasto}
    \end{itemize}
  \item \textbf{Implementação}: A combinação \texttt{(idCategoria, idGasto)} forma uma chave composta lógica que identifica unicamente cada relacionamento. Embora não seja uma constraint física no código, a validação é feita através de métodos que verificam a existência de relacionamentos duplicados antes de criar novos.
  \item \textbf{Índices}: Os índices Hash Extensível são criados usando \texttt{idCategoria} e \texttt{idGasto} separadamente, permitindo busca eficiente em ambas as direções:
    \begin{itemize}
      \item \texttt{indiceCategoriaGastos}: Usa \texttt{idCategoria} como chave
      \item \texttt{indiceGastoCategorias}: Usa \texttt{idGasto} como chave
    \end{itemize}
  \item \textbf{Campo adicional}: \texttt{ativo} (boolean) para exclusão lógica, permitindo manter histórico dos relacionamentos
\end{itemize}

\textbf{4. Como é feita a busca eficiente de registros por meio do índice?}

A busca eficiente é realizada através dos índices Hash Extensível bidirecionais:

\begin{itemize}
  \item \textbf{Busca por categoria}: Para encontrar todos os gastos de uma categoria específica:
    \begin{itemize}
      \item Utiliza o índice \texttt{indiceCategoriaGastos} com a chave \texttt{idCategoria}
      \item O Hash Extensível calcula o hash de \texttt{idCategoria} e acessa diretamente o bucket correspondente — O(1) médio
      \item Retorna a lista de objetos \texttt{CategoriaGasto} associados àquela categoria
      \item Filtra apenas relacionamentos com \texttt{ativo = true}
      \item Para cada relacionamento ativo, busca o \texttt{Gasto} correspondente na Árvore B+ usando \texttt{idGasto} — O(log n)
    \end{itemize}
  \item \textbf{Busca por gasto}: Para encontrar todas as categorias de um gasto específico:
    \begin{itemize}
      \item Utiliza o índice \texttt{indiceGastoCategorias} com a chave \texttt{idGasto}
      \item O Hash Extensível calcula o hash de \texttt{idGasto} e acessa diretamente o bucket — O(1) médio
      \item Retorna a lista de objetos \texttt{CategoriaGasto} associados àquele gasto
      \item Filtra relacionamentos ativos e busca as categorias correspondentes na Árvore B+ — O(log n) por categoria
    \end{itemize}
  \item \textbf{Complexidade total}: O(1) médio para acessar o índice + O(k) onde k = número de relacionamentos retornados + O(k × log n) para buscar as entidades relacionadas na Árvore B+
  \item \textbf{Vantagem}: O Hash Extensível elimina a necessidade de percorrer todos os relacionamentos, acessando diretamente os relevantes através do hash
\end{itemize}

\textbf{5. Como o sistema trata a integridade referencial (remoção/atualização) entre as tabelas?}

O sistema trata a integridade referencial através de exclusão lógica e validações:

\begin{itemize}
  \item \textbf{Exclusão lógica (Lápide)}:
    \begin{itemize}
      \item Quando uma \texttt{Categoria} ou \texttt{Gasto} é excluído, o campo \texttt{ativo} é marcado como \texttt{false}
      \item Os relacionamentos \texttt{CategoriaGasto} permanecem no banco de dados, mas são filtrados nas consultas
      \item Relacionamentos com entidades inativas não aparecem nos resultados de busca
      \item Isso mantém o histórico e permite recuperação de dados se necessário
    \end{itemize}
  \item \textbf{Validação antes de criar relacionamento}:
    \begin{itemize}
      \item Antes de criar um relacionamento N:N, o sistema verifica se ambas as entidades existem e estão ativas
      \item Método \texttt{buscarCategoria(idCategoria)} e \texttt{buscarGasto(idGasto)} são chamados para validar existência
      \item Apenas entidades com \texttt{ativo = true} podem ser relacionadas
    \end{itemize}
  \item \textbf{Remoção de relacionamento}:
    \begin{itemize}
      \item Método \texttt{removerCategoriaDoGasto()} marca o relacionamento como \texttt{ativo = false}
      \item O relacionamento permanece no arquivo mas não aparece nas consultas
      \item Os índices são atualizados automaticamente ao salvar
    \end{itemize}
  \item \textbf{Atualização de entidades}:
    \begin{itemize}
      \item Atualizações em \texttt{Categoria} ou \texttt{Gasto} não afetam os relacionamentos diretamente
      \item Os relacionamentos referenciam apenas os IDs, que permanecem constantes
      \item Se uma entidade for marcada como inativa, os relacionamentos automaticamente deixam de aparecer nas consultas
    \end{itemize}
  \item \textbf{Consistência de índices}:
    \begin{itemize}
      \item Os índices bidirecionais são atualizados simultaneamente ao criar ou remover relacionamentos
      \item Ao carregar do disco, os índices são reconstruídos a partir dos relacionamentos ativos
    \end{itemize}
\end{itemize}

\textbf{6. Como foi organizada a persistência dos dados dessa nova tabela (mesmo padrão de cabeçalho e lápide)?}

A persistência da tabela \texttt{CategoriaGasto} segue o mesmo padrão das outras tabelas do sistema:

\begin{itemize}
  \item \textbf{Arquivo de persistência}: \texttt{data/categoria\_gasto.db}
  \item \textbf{Formato}: Serialização Java nativa usando \texttt{ObjectOutputStream} e \texttt{ObjectInputStream}
  \item \textbf{Estrutura de armazenamento}:
    \begin{itemize}
      \item Lista de objetos \texttt{CategoriaGasto} serializados diretamente
      \item Não há cabeçalho separado — a lista é serializada como um único objeto
      \item Cada objeto \texttt{CategoriaGasto} contém: \texttt{idCategoriaGasto}, \texttt{idCategoria}, \texttt{idGasto} e \texttt{ativo}
    \end{itemize}
  \item \textbf{Exclusão lógica (Lápide)}:
    \begin{itemize}
      \item Campo \texttt{ativo} (boolean) em cada objeto \texttt{CategoriaGasto}
      \item Relacionamentos excluídos são marcados como \texttt{ativo = false} mas permanecem no arquivo
      \item Ao carregar, apenas relacionamentos com \texttt{ativo = true} são considerados nas consultas
      \item Isso mantém histórico completo dos relacionamentos para análise e possível recuperação
    \end{itemize}
  \item \textbf{Salvamento}:
    \begin{itemize}
      \item Método \texttt{salvarCategoriaGasto()} é chamado após cada operação de escrita (inserção, remoção)
      \item Serializa a lista completa de relacionamentos (incluindo inativos) para o arquivo
    \end{itemize}
  \item \textbf{Carregamento}:
    \begin{itemize}
      \item Método \texttt{carregarCategoriaGasto()} é executado automaticamente na inicialização do servidor
      \item Deserializa a lista de relacionamentos do arquivo
      \item Reconstrói os índices Hash Extensível inserindo todos os relacionamentos (ativos e inativos)
      \item As consultas filtram apenas relacionamentos ativos durante a execução
    \end{itemize}
  \item \textbf{Contador de IDs}: O contador \texttt{proximoIdCategoriaGasto} é salvo em \texttt{data/contadores.db} junto com os outros contadores
\end{itemize}

\textbf{7. Descreva como o código da tabela intermediária se integra com o CRUD das tabelas principais.}

A tabela intermediária \texttt{CategoriaGasto} se integra com o CRUD das tabelas principais da seguinte forma:

\begin{itemize}
  \item \textbf{CREATE (Criação de Gasto)}:
    \begin{itemize}
      \item No método \texttt{cadastrarGasto()}, após inserir o gasto na Árvore B+, o sistema recebe uma lista de IDs de categorias
      \item Para cada categoria na lista, chama \texttt{adicionarCategoriaAoGastoSemSalvar()} que:
        \begin{itemize}
          \item Valida se a categoria existe e está ativa
          \item Cria um novo objeto \texttt{CategoriaGasto} com ID auto-incremental
          \item Adiciona à lista \texttt{relacionamentosCategoriaGasto}
          \item Atualiza os índices bidirecionais (\texttt{indiceCategoriaGastos} e \texttt{indiceGastoCategorias})
        \end{itemize}
      \item Após criar todos os relacionamentos, chama \texttt{salvarCategoriaGasto()} uma única vez para persistir
    \end{itemize}
  \item \textbf{READ (Leitura de Gastos e Categorias)}:
    \begin{itemize}
      \item Ao buscar um gasto, o método \texttt{buscarCategoriasDoGasto(idGasto)} é chamado para retornar todas as categorias associadas
      \item Utiliza o índice \texttt{indiceGastoCategorias} para buscar relacionamentos — O(1) médio
      \item Filtra relacionamentos ativos e busca as categorias correspondentes na Árvore B+
      \item Similarmente, \texttt{buscarGastosPorCategoria(idCategoria)} retorna todos os gastos de uma categoria
    \end{itemize}
  \item \textbf{UPDATE (Atualização)}:
    \begin{itemize}
      \item Atualizações em \texttt{Categoria} ou \texttt{Gasto} não modificam diretamente os relacionamentos
      \item Os relacionamentos referenciam apenas IDs, que permanecem constantes
      \item Se necessário adicionar/remover categorias de um gasto existente, métodos específicos são chamados:
        \begin{itemize}
          \item \texttt{adicionarCategoriaAoGasto()} para adicionar nova categoria
          \item \texttt{removerCategoriaDoGasto()} para remover categoria (exclusão lógica)
        \end{itemize}
    \end{itemize}
  \item \textbf{DELETE (Exclusão Lógica)}:
    \begin{itemize}
      \item Quando um \texttt{Gasto} é excluído (lógica), os relacionamentos permanecem mas não aparecem nas consultas
      \item Quando uma \texttt{Categoria} é excluída (lógica), os relacionamentos permanecem mas não aparecem nas consultas
      \item O método \texttt{removerCategoriaDoGasto()} marca um relacionamento específico como inativo
      \item Todos os métodos de busca filtram relacionamentos com \texttt{ativo = false}
    \end{itemize}
  \item \textbf{Integração com API REST}:
    \begin{itemize}
      \item O endpoint \texttt{POST /api/expenses} recebe \texttt{categoryIds} como array
      \item O handler chama \texttt{cadastrarGasto()} que internamente cria os relacionamentos N:N
      \item Ao retornar gastos via \texttt{GET /api/transactions}, o sistema inclui as categorias associadas usando \texttt{buscarCategoriasDoGasto()}
    \end{itemize}
  \item \textbf{Sincronização}:
    \begin{itemize}
      \item Todas as operações que modificam relacionamentos chamam \texttt{salvarCategoriaGasto()} para persistir
      \item Os índices são atualizados imediatamente após cada modificação
      \item A persistência garante que os dados sejam mantidos entre execuções do servidor
    \end{itemize}
\end{itemize}

\textbf{8. Descreva como está organizada a estrutura de diretórios e módulos no repositório após esta fase.}

Após a implementação da Fase III, a estrutura de diretórios e módulos do repositório está organizada da seguinte forma:

\begin{itemize}
  \item \textbf{src/} — Código-fonte Java:
    \begin{itemize}
      \item \texttt{BancoDados.java}: Classe principal que gerencia todas as tabelas, índices e relacionamentos N:N
      \item \texttt{Entidades.java}: Contém as classes de domínio, incluindo \texttt{CategoriaGasto} e \texttt{TransacaoTag}
      \item \texttt{ArvoreBPlus.java}: Implementação da Árvore B+ para índices primários
      \item \texttt{HashExtensivel.java}: Implementação do Hash Extensível para índices secundários e relacionamentos N:N
      \item \texttt{ControleSeServer.java}: Servidor HTTP com API REST e handlers para todas as operações
      \item \texttt{server/handlers/}: Handlers modulares para diferentes endpoints (CategoriesHandler, AccountsHandler, etc.)
      \item \texttt{server/utils/}: Utilitários (JsonUtil, RequestUtil, ResponseUtil)
    \end{itemize}
  \item \textbf{data/} — Arquivos de persistência:
    \begin{itemize}
      \item \texttt{usuarios.db}, \texttt{categorias.db}, \texttt{gastos.db}, \texttt{receitas.db}, \texttt{contas.db}, \texttt{orcamentos.db}, \texttt{tags.db}: Tabelas principais
      \item \texttt{categoria\_gasto.db}: Tabela intermediária para relacionamento N:N Categoria-Gasto
      \item \texttt{transacao\_tag.db}: Tabela intermediária para relacionamento N:N Tag-Transação
      \item \texttt{contadores.db}: Contadores de IDs auto-incrementais (incluindo \texttt{proximoIdCategoriaGasto} e \texttt{proximoIdTransacaoTag})
    \end{itemize}
  \item \textbf{docs/} — Documentação:
    \begin{itemize}
      \item \texttt{main.tex}: Fonte LaTeX da documentação completa (Fases I, II e III)
      \item \texttt{der.png}, \texttt{caso.png}: Diagramas do projeto
      \item PDFs das especificações de cada fase
    \end{itemize}
  \item \textbf{Raiz do projeto}:
    \begin{itemize}
      \item \texttt{index.html}, \texttt{styles.css}, \texttt{app.js}: Frontend web completo
      \item \texttt{README.md}: Documentação do projeto com instruções de uso
      \item \texttt{Dockerfile}, \texttt{render.yaml}: Configurações para deploy
    \end{itemize}
  \item \textbf{Organização modular}:
    \begin{itemize}
      \item \textbf{Camada de persistência}: \texttt{BancoDados.java} centraliza todas as operações de banco de dados
      \item \textbf{Camada de entidades}: \texttt{Entidades.java} contém todas as classes de domínio
      \item \textbf{Camada de estruturas}: \texttt{ArvoreBPlus.java} e \texttt{HashExtensivel.java} são estruturas reutilizáveis
      \item \textbf{Camada de API}: \texttt{ControleSeServer.java} e handlers modulares gerenciam requisições HTTP
      \item \textbf{Separação de responsabilidades}: Cada módulo tem responsabilidade clara e bem definida
    \end{itemize}
  \item \textbf{Integração dos relacionamentos N:N}:
    \begin{itemize}
      \item Métodos de relacionamento N:N estão em \texttt{BancoDados.java} na seção "OPERAÇÕES DE RELACIONAMENTO N:N"
      \item Classes \texttt{CategoriaGasto} e \texttt{TransacaoTag} estão em \texttt{Entidades.java}
      \item Índices Hash Extensível para relacionamentos são inicializados em \texttt{BancoDados.java}
      \item Persistência de relacionamentos segue o mesmo padrão das outras tabelas
    \end{itemize}
\end{itemize}

\end{document}
